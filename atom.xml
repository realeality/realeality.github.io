<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fumingy的博客</title>
  
  <subtitle>学习前端的一小步</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-27T13:12:56.587Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络是如何连接的 第四章 通过接入网进入互联网内部</title>
    <link href="http://example.com/2020/10/26/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%80%9A%E8%BF%87%E6%8E%A5%E5%85%A5%E7%BD%91%E8%BF%9B%E5%85%A5%E4%BA%92%E8%81%94%E7%BD%91%E5%86%85%E9%83%A8/"/>
    <id>http://example.com/2020/10/26/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E9%80%9A%E8%BF%87%E6%8E%A5%E5%85%A5%E7%BD%91%E8%BF%9B%E5%85%A5%E4%BA%92%E8%81%94%E7%BD%91%E5%86%85%E9%83%A8/</id>
    <published>2020-10-26T14:42:00.000Z</published>
    <updated>2020-10-27T13:12:56.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释">名词解释</h2><p><strong>ADSL</strong>： Asymmetric Digital Subscriber Line，不对称数字用户线。它是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向（用户到互联网）和下行方向（互联网到用户）的通信速率是不对称的。</p><p><strong>光纤</strong>：光纤就是把要传送的数据由电信号转换为光信号进行通讯。在光纤的两端分别都装有“光猫”进行信号转换。光纤是宽带网络中多种传输媒介中最理想的一种，它的特点是传输容量大，传输质量好，损耗小，中继距离长等。光纤传输使用的是波分复用，即是把小区里的多个用户的数据利用PON技术汇接成为高速信号，然后调制到不同波长的光信号在一根光纤里传输。</p><p><strong>接入网</strong>：接入网是业务接点（对电话业务而言为本地交换机）与用户端设备（CPE）之间的实施系统，它包括复用、交叉连接和传输功能，可以部分或全部代替传统的用户本地线路网。有线接入网的方式有：非对称数字用户环路（ADSL）、光纤接入（FTTB、FTTC、FTTO、FTTH等）、光纤同轴混合接入（HFC）、高速数字用户环路（HDSL）、铜线接入等。</p><a id="more"></a><p>**光纤宽带和ADSL接入方式的区别：**ADSL是电信号传播，光纤宽带是光信号传播。ADSL是一人享用一根电话线上网，在这根电话线里还有你的电话机使用的语音信号。而光纤宽带则是通到小区，然后分别通过超5类网线通到各用户，这样上网是上网，打电话是打电话，小区里的用户共享一根光纤足够了。</p><p><strong>ADSL Modem</strong>：即ADSL调制解调器（modem俗称猫），是计算机与电话线之间进行信号转换的装置，由调制器和解调器两部分组成，调制器是把计算机的数字信号（如文件等）调制成可在电话线上传输的声音信号的装置，在接收端，解调器再把声音信号转换成计算机能接收的数字信号。通过调制解调器和电话线就可以实现计算机之间的数据通信。</p><p><strong>ADSL和ADSL Modem的区别</strong>：简单的说ADSL是一种上网方式，而MODEM是一种上网设备。</p><p><strong>路由器和ADSL Modem的区别</strong>：ADSL Modem（猫）是将网络运营商服务端提供宽带信号转换成电脑所能识别的宽带信号,是一对一的，一头接电话线，一头接网线。而路由器是用来将数据转发,或者组建小型局域网络,实现两台或以上电脑同时上网，接的是网线。</p><p><strong>分辨路由器和猫</strong>：如果一个WAN，四个LAN，百分之百是路由器，如果一个是RJ11（也就是电话接口），四个LAN，那就肯定是路由猫了，这个东东不是很好用，最好的办法还是猫，路由器分开来使用，毕竟路由器要好设置多了。来源：百度知道</p><p><strong>路由猫</strong>：路由猫是一种将路由器与调制解调器（俗称“猫”）合二为一的产品，该产品同时具备调制解调、路由两大功能。单一个modem可以让一台电脑上网，再加一个路由器就可以让多台电脑同时上网，数量取决于路由器的接口。 现在市场上有二者的结合体，就是路由猫了，只通过这一个设备就可以实现一台或者多台电脑同时上网。</p><p><strong>信元</strong>：信元是一种特殊的数据结构，不同于普通网络传输的帧或者包，因为帧和包是变长的，而ATM的信元是定长的，非常小的，长度只有53个字节，其中5个字节是信元头，48个字节是信息段。信息段中可以是各类业务的用户数据，信元头包含各种控制信息。</p><p><strong>ATM</strong>：ATM是Asynchronous Transfer Mode异步传输模式的缩写。与同步传递模式(STM)不同，ATM采用异步时分复用技术(统计复用)。来自不同信息源的信息汇集在一个缓冲器内排队。列中的信元逐个输出到传输线上，形成首尾相连的信息流。ATM具有以下特点：因传输线路质量高，不需要逐段进行差错控制。ATM在通信之前需要先建立一个虚连接来预留网络资源，并在呼叫期间保持这一连接，所以ATM以面向连接的方式工作。</p><p><strong>DSLAM</strong>：  DSL Access Multiplexer，数字用户线接入复用设备，它是一种电话局用的多路 ADSL Modem，可以理解为将多个 ADSL Modem 整合在一个外壳里的设备。</p><p><strong>BAS</strong>： Broadband Access Server，宽带接入服务器。它也是一种路由器，负责将 ATM 信元还原成网络包并转发到互联网内部。</p><p><strong>FTTH</strong>： Fiber To The Home，指光纤到户。指的是将光纤接入家庭的意思。</p><p><strong>PPP</strong>：PPP（Point-to-Point Protocol）点对点协议。PPP协议中提供了一整套方案来解决链路建立、维护、拆除、上层协议协商、认证等问题。</p><p><strong>PPPoE</strong>：PPPoE: PPP over Ethernet，即以太网上的点对点协议，是经常被用在DSL链接上的变种协议(RFC 2516)，另外PPPoA 有时也被使用(PPP over ATM)。</p><p><strong>POP</strong>： Point of Presense，中文一般叫作“接入点”。</p><p><strong>NOC</strong>： Network Operation Center，网络运行中心。</p><h2 id="前言">前言</h2><p>**互联网的基本结构和家庭、公司网络是相同的 **</p><p>​互联网是一个遍布世界的巨大而复杂的系统， 但其基本工作方式却出奇地简单。 和家庭、 公司网络一样， 互联网也是通过路由器来转发包的，而且路由器的基本结构和工作方式也并没有什么不同（ 图 4.1）。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024222054070.png" alt="image-20201024222054070"></p><p>​</p><p>​当然， 互联网也有一些和家庭、 公司网络不同的地方， 距离的不同和路由的维护方式， 就是互联网与家庭、 公司网络之间最主要的两个不同点。</p><p>​从上一章内容可以知道，网络包通过交换机和路由器的转发一步一步地接近它的目的地， 在通过互联网接入路由器之后， 就进入了互联网。</p><p>​互联网接入路由器的包转发操作和以太网路由器几乎是一样的。  即，根据包 IP 头部中的接收方 IP 地址在路由表的目标地址中进行匹配， 找到相应的路由记录后将包转发到这条路由的目标网关。</p><p>​所谓接入网， 就是指连接互联网与家庭、 公司网络的通信线路 A。 一般家用的接入网方式包括 ADSLB、 FTTHC、 CATV、 电话线、 ISDN 等， 公司则还可能使用专线。 接入网的线路有很多种类， 我们无法探索所有这些线路， 因此下面先介绍一个比较有代表性的例子——ADSL。</p><h2 id="ADSL-接入网的结构和工作方式">ADSL 接入网的结构和工作方式</h2><p>​1. <strong>ADSL</strong></p><p>​在网络包从用户传输到运营商的过程中， 会变换几种不同的形态， 整个过程如图 4.3 所示。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024223006202.png" alt="image-20201024223006202"></p><p>​客户端生成的网络包（ 图 4.3 的①和②） 先经过集线器和交换机到达互联网接入路由器（ 图 4.3 ③）， 并在此从以太网包中取出 IP 包并判断转发目标（ 图 4.3 ④）  如果互联网接入路由器和 ADSL Modem 之间是通过以太网连接的， 那么就会按照以太网的规则执行包发送的操作。</p><p>​发送信号本身的过程跟之前是一样的，但以太网的头部会有一些差异，网络包会加上 MAC 头部、 PPPoE 头部、 PPP头部总共 3 种头部（ 图 4.3 ⑤），然后按照以太网规则转换成电信号后被发送出去。</p><p>​互联网接入路由器将包发送出去之后， 包就到达了 ADSL Modem（ 图 4.3 ⑥）， 然后， ADSL Modem 会把包拆分成很多小格子（ 图 4.3 ⑦），每一个小格子称为一个信元。 信元是一个非常小的数据块， 开头是有 5 个字节的头部， 后面是 48 个字节的数据， 用于一种叫作 ATM （Asynchronous Transfer Mode，异步传输  ）的通信技术。信元在原理上跟 TCP/IP 将应用程序的数据拆分成块装进一个个包的过程是一样的。</p><p>​ADSL 将信元“调制”成信号。ADSL Modem 采用了一种用圆滑波形（ 正弦波） 对信号进行合成来表示 0 和 1 的技术， 这种技术称为调制。</p><p>​ADSL 也会通过使用多个波来提高速率。如图 4.6 所示， ADSL 使用间隔为 4.3125 kHz 的上百个不同频率的波进行合成， 每个波都采用正交振幅调制， 而且， 根据噪声等条件的不同， 每个波表示的比特数是可变的。 也就是说， 噪声小的频段可以给波分配更多的比特， 噪声大的频段则给波分配较少的比特， 每个频段表示的比特数加起来， 就决定了整体的传输速率。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026213751623.png" alt="image-20201026213751623"></p><ol start="2"><li><strong>分离器</strong></li></ol><p>​ADSL Modem 将信元转换为电信号之后， 信号会进入一个叫作分离器的设备， 然后 ADSL 信号会和电话的语音信号混合起来一起从电话线传输出去。</p><p>​分离器需要负责将电话和 ADSL 的信号进行分离（ 图 4.7）。 电话线传入的信号是电话的语音信号和 ADSL 信号混合在一起的， 如果这个混合信号直接进入电话机， ADSL 信号就会变成噪音， 导致电话难以听清。 为了避免这样的问题， 就需要通过分离器将传入的信号分离， 以确保 ADSL信号不会传入电话机。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026214035898.png" alt="image-20201026214035898"></p><ol start="3"><li><strong>通过 DSLAM 到达 BAS</strong></li></ol><p>​信号通过电话线到达电话局之后， 会经过配线盘、 分离器到达 DSLAM（ 图 4.3 ⑨），在这里， 电信号会被还原成数字信息——信元（ 图 4.3 ⑩）。DSLAM 通过读取信号波形， 根据振幅和相位判断对应的比特值， 将信号还原成数字信息， 这一过程和用户端的 ADSL Modem 在接收数据时的过程是一样的。</p><p>​不过， DSLAM 和用户端 ADSL Modem 相比还是有一个不同的地方。用户端 ADSL Modem 具备以太网接口， 可以与用户端的路由器和计算机交互， 收发以太网包， 而 DSLAM 一般不用以太网接口， 而是用 ATM 接口，和后方路由器收发数据时使用的是原始网络包拆分后的 ATM 信元形式。</p><p>​信元从 DSLAM 出来之后， 会到达一个叫作 BAS 的包转发设备（ 图 4.3⑪）。 BAS 和 DSLAM 一样， 都具有 ATM 接口， 可以接收 ATM 信元， 还可以将接收到的 ATM 信元还原成原始的包（ 图 4.3⑫）。</p><p>​接下来， 它会将收到的包前面的 MAC 头部和PPPoE 头部丢弃， 取出 PPP 头部以及后面的数据（ 图4.3⑬）。 MAC 头部和PPPoE 头部的作用是将包送达 BAS 的接口， 当接口完成接收工作后， 它们就完成了使命， 可以被丢弃了。 具有以太网接口的路由器在接收到包之后也会丢弃其中的 MAC 头部， 道理是一样的。 接下来， BAS 会在包的前面加上隧道专用头部， 并发送到隧道的出口（ 图 4.3⑭）。</p><p>​然后， 网络包会到达隧道出口的隧道专用路由器（图 4.3⑮）， 在这里隧道头部会被去掉， IP 包会被取出（图 4.3⑯）， 并被转发到互联网内部（4.3⑰）。</p><h2 id="光纤接入网（FTTH）">光纤接入网（FTTH）</h2><ol><li><strong>光纤的基本知识</strong></li></ol><p>​FTTH是一种基于光纤的接入网技术，其关键点在于对光纤的使用。</p><p>​光纤的结构如图 4.9 所示， 它是由一种双层结构的纤维状透明材质（ 玻璃和塑料） 构成的， 通过在里面的纤芯中传导光信号来传输数字信息（ 图4.10）。 ADSL 信号是由多个频段的信号组成的， 比较复杂， 但光信号却非常简单， 亮表示 1， 暗表示 0。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026220126214.png" alt="image-20201026220126214"></p><p>​数字信息并不能一下子变成光信号， 而是需要像图 4.10 所示的这样， 先将数字信息转换成电信号， 然后再将电信号转换成光信号。 这里的电信号非常简单， 1 用高电压表示， 0 用低电压表示。 将这样的电信号输入 LED、 激光二极管等光源后， 这些光源就会根据信号电压的变化发光，高电压发光亮， 低电压发光暗。 这样的光信号在光纤中传导之后， 就可以通过光纤到达接收端。 接收端有可以感应光线的光敏元件， 光敏元件可以根据光的亮度产生不同的电压。 当光信号照射到上面时， 光亮的时候就产生高电压， 光暗的时候就产生低电压， 这样就将光信号转换成了电信号。最后再将电信号转换成数字信息， 我们就接收到数据了。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026220211148.png" alt="image-20201026220211148"></p><ol start="2"><li><strong>通过光纤分路来降低成本</strong></li></ol><p>​用光纤来代替 ADSL 将用户端接入路由器和运营商的 BAS 连接起来的接入方式就是 FTTH， 从形态上可大致分为两种。</p><p>​一种是用一根光纤直接从用户端连接到最近的电话局（ 图 4.16(a)）。这种类型的 FTTH 中， 用户和电话局之间通过光纤直接连接。  另一种光纤的接入方式是在用户附近的电线杆上安装一个名为分光器的设备， 通过这个设备让光纤分路， 同时连接多个用户 A（ 图 4.16(b)）。在这种方式下， 用户端不使用光纤收发器， 而是使用一个叫作 ONUB 的设备，它将以太网的电信号转换成光信号之后， 会到达 BAS 前面的一个叫作OLTC 的设备。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026220516405.png" alt="image-20201026220516405"></p><h2 id="接入网中使用的-PPP-和隧道">接入网中使用的 PPP 和隧道</h2><ol><li><strong>用户认证和配置下发</strong></li></ol><p>​互联网本来就是由很多台路由器相互连接组成的， 因此原则上应该是将接入网连接到路由器上。 随着接入网发展到 ADSL 和 FTTH， 接入网连接的路由器也跟着演进， 而这种进化型的路由器就叫作 BAS。</p><p>​首先是用户认证和配置下发功能。 ADSL 和 FTTH 接入网中， 都需要先输入用户名和密码， 登录之后才能访问互联网， 而 BAS 就是登录操作的窗口。 BAS 使用 PPPoE方式来实现这个功能。 PPPoE 是由传统电话拨号上网上使用的 PPP 协议发展而来的。 在使用电话线或者 ISDN 拨号上网时， PPP 是如图 4.17 这样工作的。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026220804788.png" alt="image-20201026220804788"></p><p>​首先，用户向运营商的接入点拨打电话（图 4.17 ① -1）， 电话接通后（图 4.17 ① -2）输入用户名和密码进行登录操作（图 4.17 ② -2）。 用户名和密码通过 RADIUS协议（Remote Authentication Dial-in User Service，远程认证拨号用户服务）从 RASG 发送到认证服务器， 认证服务器校验这些信息是否正确。 当确认无误后， 认证服务器会返回 IP 地址等配置信息， 并将这些信息下发给用户（图 4.17 ② -3）。 用户的计算机根据这些信息配置 IP 地址等参数， 完成 TCP/IP 收发网络包的准备工作， 接下来就可以发送 TCP/IP 包了（ 图 4.17 ③）。</p><ol start="2"><li><strong>在以太网上传输 PPP 消息</strong></li></ol><p>​ADSL 和 FTTH 接入方式也需要为计算机分配公有地址才能上网， 这一点和拨号上网是相同的。 不过， ADSL 和 FTTH 中， 用户和 BAS 之间是通过电缆或光纤固定连接在一起的， 因此没有必要验证用户身份， 所以实际上并不需要 PPP 的所有这些功能。 然而， 通过用户名和密码登录的步骤可以根据用户名来切换不同的运营商， 这很方便。 因此， 接入运营商在ADSL 和 FTTH 中一般也会使用 PPP。</p><ol start="3"><li><strong>通过隧道将网络包发送给运营商</strong></li></ol><p>​BAS 除了作为用户认证的窗口之外， 还可以使用隧道方式来传输网络包。 所谓隧道， 就类似于套接字之间建立的 TCP 连接。   像这样， 如果在 BAS 和运营商路由器之间的 ADSL/FTTH 接入服务商的网络中建立一条隧道， 将用户到 BAS 的接入网连接起来， 就形成了一条从用户一直到运营商路由器的通道， 网络包通过这条通道， 就可以进入互联网内部了， 这样的机制就类似于将接入网一直延伸到运营商路由器。</p><p>​隧道有几种实现方式， 一种是 TCP 连接（ 图 4.19(a)），另一种是基于封装（ encapsulation） 的隧道实现方式，这种方式是将包含头部在内的整个包装入另一个包中传输到隧道的另一端。 在这种方式中， 包本身可以原封不动地到达另一端的出口， 从结果上看和基于 TCP 连接的方式是一样的， 都实现了一个可供包进行穿梭的通道。其实，无论任何机制， 只要能够将包原封不动搬运到另一端， 从原理上看就都可以用来建立隧道。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026221814087.png" alt="image-20201026221814087"></p><ol start="4"><li><strong>接入网的整体工作过程</strong></li></ol><p>​接入网的工作从用户端的互联网接入路由器进行连接操作开始。 首先，接入路由器中需要配置运营商分配的用户名和密码。 然后， 接入路由器会根据 PPPoE 的发现机制来寻找 BAS。 这一机制和 ARP 一样是基于广播来实现的。 即，互联网接入路由器通过 PPPoE 的发现机制查询 BAS 的 MAC 地址。    接下来，进入用户认证和下发配置的阶段。AS 下发的 TCP/IP 参数会被配置到互联网接入路由器的 BAS端的端口上，这样路由器就完成接入互联网的准备了。</p><p>​接下来， 客户端就会开始发送用来访问互联网的网络包，这些包的目的地是互联网中的某个地方， 这个地方或许在互联网接入路由器的路由表里是找不到的。 这时， 路由器会选择默认路由， 并将这个包转发给默认路由的网关地址， 也就是 BAS 下发的默认路由。  只不过在通过路由表判断转发目标之后， 包不是按照以太网规则转发， 而是按照 PPPoE 规则转发，如图 4.20。</p><pre><code>  ![image-20201026222423627](D:\文档\电子书笔记\typora-user-images\image-20201026222423627.png)</code></pre><p>​接下来， 网络包会到达 BAS，BAS 在收到用户路由器发送的网络包之后，会去掉 MAC 头部和PPPoE 头部，然后用隧道机制将包发送给网络运营商的路由器。</p><ol start="5"><li><p><strong>除 PPPoE 之外的其他方式</strong></p><p>（1）使用 PPPoA 方式的 ADSL 接入网</p><p>​ADSL 使用PPPoE 方式时， 是先将 PPP 消息装入以太网包中， 然后再将以太网包拆分并装入信元， 而PPPoA 方式是直接将 PPP 消息装入信元（ 图 4.21）。即，PPPoA 方式不添加 MAC 头部和 PPPoE 头部，而是直接将包装入信元中。</p><pre><code> ![image-20201026222851579](D:\文档\电子书笔记\typora-user-images\image-20201026222851579.png)</code></pre><p>（2）使用 DHCP  方式</p><p>​DHCP  原理如图 4.22 所示， 首先客户端请求配置信息（ 图 4.22 ①）， 然后 DHCP服务器下发配置信息（图 4.22 ②）， 非常简单， 不需要像 PPP（图 4.17） 那样需要多个步骤， 也不需要验证用户名和密码。</p></li></ol><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026223008337.png" alt="image-20201026223008337"></p><h2 id="网络运营商的内部">网络运营商的内部</h2><p><strong>POP 和 NOC</strong></p><p>联网的实体并不是由一个组织运营管理的单一网络， 而是由多个运营商网络相互连接组成的（ 图 4.23），ADSL、 FTTH 等接入网是与用户签约的运营商设备相连的， 这些设备称为 POP，互联网的入口就位于这里 。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026223128610.png" alt="image-20201026223128610"></p><p>​POP 的结构根据接入网类型以及运营商的业务类型不同而不同， 大体上是图 4.24 中的这个样子。 POP 中包括各种类型的路由器， 路由器的基本工作方式是相同的， 但根据其角色分成了不同的类型。 图 4.24 中， 中间部分列出了连接各种接入网的路由器， 这里的意思就是根据接入网的类型需要分别使用不同类型的路由器。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026223310339.png" alt="image-20201026223310339"></p><p>​NOC是运营商的核心设备， 从 POP 传来的网络包都会集中到这里，并从这里被转发到离目的地更近的 POP， 或者是转发到其他的运营商。 这里也需要配备高性能的路由器。</p><p>​其实， NOC 和 POP 并没有非常严格的界定。 NOC 里面也可以配备连接接入网的路由器， 很多情况下是和 POP 共用的。 从 IP 协议的传输过程来看， 也没有对两者进行区分的必然性， 因为无论是哪个路由器， 其转发网络包的基本工作原理都是相同的。 因此可以简单地认为， NOC 就是规模扩大后的 POP。</p><p>​POP 和 NOC 遍布全国各地， 它们各自的规模有大有小， 但看起来跟公司里的机房没什么太大区别， 都是位于一幢建筑物中的， 其中的路由器或者通过线路直接连接， 或者通过交换机进行连接， 这些和公司以及家庭网络都是相同的。</p><h2 id="跨越运营商的网络包">跨越运营商的网络包</h2><ol><li><strong>运营商之间的连接</strong></li></ol><p>​如果服务器的运营商和客户端的运营商不同，网络包需要先发到服务器所在的运营商， 这些信息也可以在路由表中找到，  网络包会被转发到对方运营商的路由器。</p><ol start="2"><li><strong>运营商之间的路由信息交换</strong></li></ol><p>如图 4.25 所示，  只要获得了对方的路由信息， 就可以知道对方路由器连接的所有网络， 将这些信息写入自己的路由表中， 也就可以向那些网络发送包了。</p><p>​获得对方的路由信息之后， 我们也需要将自身的路由信息告知对方。这样一来， 对方也可以将发往我们所在子网的包转发过来。 这个路由信息交换的过程是由路由器自动完成的， 这里使用的机制称为 BGP（Border Gateway Protocol，边界网关协议）。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026223756185.png" alt="image-20201026223756185"></p><p>​根据所告知的路由信息的内容， 这种路由交换可分为两类。 一类是将互联网中的路由全部告知对方。 例如图 4.26 中， 如果运营商 D 将互联网上所有路由都告知运营商 E， 则运营商 E 不但可以访问运营商 D， 还可以访问运营商 D 后面的运营商 B、 A 和 C。 然后， 通过运营商 D 就可以向所有的运营商发送包。 像这样， 通过运营商 D 来发送网络包的方式称为转接。  另一种类型是两个运营商之间仅将与各自网络相关的路由信息告知对方。 这样， 只有双方之间的网络可以互相收发网络包， 这种方式称为非转接， 也叫对等。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026223915065.png" alt="image-20201026223915065"></p><ol start="3"><li><strong>IX 的必要性</strong></li></ol><p>​IX： Internet eXchange，中文一般叫作“互联网交换中心”。  对于两个运营商来说， 像图 4.26 中运营商 D 和运营商 C 这样一对一的连接是最基本的一种连接方式，   但这种方式有个不方便的地方， 如果运营商之间只能一对一连接， 那么就需要像图 4.27（ a） 这样将所有的运营商都用通信线路连接起来，这样连接非常困难。</p><p>​我们可以采用图 4.27（ b） 的方式，设置一个中心设备， 通过连接到中心设备的方式来减少线路数量， 这个中心设备就称为 IX。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026224042100.png" alt="image-20201026224042100"></p><p>​IX的核心是具有大量高速以太网 A端口的二层交换机（ 图4.28）。 二层交换机的基本原理和一般交换机相同， 大家可以认为 IX 的核心就是大型的、 高速的交换机。</p><p>​下面来看一看网络包具体是如何传输的。 其实这里并没有什么特别需要解释的， 因为 IX 的交换机和一般的交换机在工作方式上没有区别，路由器发送网络包时， 先通过 ARP 查询下一个路由器的 MAC 地址， 然后将其写入 MAC 头部发送出去即可。 只要填写了正确的 MAC 地址， 就可以向任何运营商的路由器发送包。 不过实际上， 要成功发送包还需要正确的路由信息， 对于没有进行路由交换的运营商， 我们是无法向其发送包的。这需要运营商之间通过谈判签订合约， 然后按照合约来交换路由信息， 实现网络包的收发。  运营商之间可以直接连接， 也可以通过 IX 连接， 无论是哪种方式，  最终网络包都会到达服务器所在的运营商， 然后通过 POP 进入服务器端的<br>网络。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201026224157783.png" alt="image-20201026224157783"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ADSL&lt;/strong&gt;： Asymmetric Digital Subscriber Line，不对称数字用户线。它是一种利用架设在电线杆上的金属电话线来进行高速通信的技术，它的上行方向（用户到互联网）和下行方向（互联网到用户）的通信速率是不对称的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;光纤&lt;/strong&gt;：光纤就是把要传送的数据由电信号转换为光信号进行通讯。在光纤的两端分别都装有“光猫”进行信号转换。光纤是宽带网络中多种传输媒介中最理想的一种，它的特点是传输容量大，传输质量好，损耗小，中继距离长等。光纤传输使用的是波分复用，即是把小区里的多个用户的数据利用PON技术汇接成为高速信号，然后调制到不同波长的光信号在一根光纤里传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接入网&lt;/strong&gt;：接入网是业务接点（对电话业务而言为本地交换机）与用户端设备（CPE）之间的实施系统，它包括复用、交叉连接和传输功能，可以部分或全部代替传统的用户本地线路网。有线接入网的方式有：非对称数字用户环路（ADSL）、光纤接入（FTTB、FTTC、FTTO、FTTH等）、光纤同轴混合接入（HFC）、高速数字用户环路（HDSL）、铜线接入等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端笔记" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络是如何连接的 第三章 从网线到网络设备</title>
    <link href="http://example.com/2020/10/24/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BB%8E%E7%BD%91%E7%BA%BF%E5%88%B0%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2020/10/24/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%BB%8E%E7%BD%91%E7%BA%BF%E5%88%B0%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</id>
    <published>2020-10-24T13:07:00.000Z</published>
    <updated>2020-10-27T12:16:19.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释">名词解释</h2><p><strong>局域网</strong>：局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。局域网通常是分布在一个有限地理范围内的网络系统，一般所涉及的地理范围只有几公里。局域网专用性非常强，具有比较稳定和规范的拓扑结构。</p><p>**双绞线：**双绞线是一种传输介质，由二根包着绝缘材料的细铜线按一定的比率相互缠绕而成。二根线双绞缠绕，改变了电缆原有的电子特性，不但可以减少自身的串扰，也可以最大程度上防止其它电缆上的信号对这对线缆上的干扰。</p><p><img src="http://img.mp.sohu.com/upload/20170526/d3113b0b7179436faced571f4ed2a3ee.png" alt="img"></p><a id="more"></a><p>我们今天在计算机通信网络中所用到的基本上都是“超五类非屏蔽双绞线缆”。线缆的二头分别按一定的线序压在RJ45水晶头内，这也就是通常大家说的“网线”。</p><p><img src="http://img.mp.sohu.com/upload/20170526/c6db33814a064da89cac779cfbf0016c_th.png" alt="img"></p><p><strong>集线器</strong>：集线器(HUB)是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备；是一个多端口的转发器。属于数据通信系统中的基础设备,它和双绞线等传输介质一样,是一种不需任何软件支持或只需很少管理软件管理的硬件设备。集线器工作在局域网(LAN)环境,像网卡一样,应用于OSI参考模型第一层,因此又被称为物理层设备。</p><p><strong>交换机</strong>：是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。其他常见的还有电话语音交换机、光纤交换机等。</p><p><strong>交换式集线器</strong>：目前，集线器和交换机之间的界限已变得模糊。交换式集线器(SH: Switching Hubs）有一个核心交换式背板，采用一个纯粹的交换系统代替传统的共享介质中继网段。交换式集线器是一种网络开关，也称交换器，由于和电话交换机对出入线的选择有相似的原理，因此也有人译为交换机。</p><p>**路由器：**所谓“路由”，是指把数据从一个地方bai传送到另一个地方的行为和动作，而路由器，正是执行这种行为动作的机器，它的英文名称为Router,是一种连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读懂”对方的数据，从而构成一个更大的网络。</p><p>​为了完成“路由”的工作，在路由器中保存着各种传输路径的相关数据－－路由表（Routing Table），供路由选择时使用。路由表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容。路由表可以是由系统管理员固定设置好的，也可以由系统动态修改，可以由路由器自动调整，也可以由主机控制。</p><p>**网关：**网关英文名称为Gateway，又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器，与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p><p>​通俗点形容，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关（Gateway）就是一个网络连接到另一个网络的**“关口”**。也就是网络关卡。</p><p><strong>路由器与网关</strong>：通常我们说的网关其实是一个逻辑概念，而路由器是一个具体的硬件。通常网关是具有路由功能的设备上实现的，其作用就是用来连接两个不同网段的网络的。如果类比的话，网关相当于软件，路由器则是硬件。软件要在硬件上运行。而硬件却不一定装这个叫网关的软件。</p><p>​目前可以当网关的东西还真不少，比如防火墙、路由器、三层交换机、电脑、部分MCU、一些存储设备，还有一些设备也很古怪的可以设置成网关，比如视频会议终端、语音网关等。所以说具有路由功能的硬件原则上都可以当网关使唤。</p><h2 id="信号在网线和集线器中传输">信号在网线和集线器中传输</h2><p>​从计算机发送出来的网络包会通过集线器、 路由器等设备被转发， 最终到达目的地。  所有的包在传输到目的地的过程中都是独立的， 相互之间没有任何关联。</p><p>​信号到达集线器的时候并不是跟刚发送出去的时候一模一样。集线器收到的信号有时会出现衰减（ 图 3.3）。 信号在网线的传输过程中，能量会逐渐损失。 网线越长， 信号衰减就越严重。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024170935878.png" alt="image-20201024170935878"></p><p>​局域网网线使用的是双绞线， 其中“双绞” 的意思就是以两根信号线为一组缠绕在一起， 这种拧麻花一样的设计是为了抑制噪声的影响。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024171047361.png" alt="image-20201024171047361"></p><p>​当信号到达集线器后， 会被广播到整个网络中。 以太网的基本架构就是将包发到所有的设备， 然后由设备根据接收方 MAC 地址来判断应该接收哪些包， 而集线器就是这一架构的忠实体现， 它就是负责按照以太网的基本架构将信号广播出去。</p><p>​信号到达集线器的 PHY（ MAU） 模块后， 会进入中继电路。 中继电路的基本功能就是将输入的信号广播到集线器的所有端口上。</p><p>​由于集线器只是原封不动地将信号广播出去， 所以即便信号受到噪声的干扰发生了失真， 也会原样发送到目的地。 这时， 接收信号的设备， 也就是交换机、 路由器、 服务器等， 会在将信号转换成数字信息后通过 FCSA校验发现错误， 并将出错的包丢弃。  协议栈的 TCP 模块会检测到丢包，并对该包进行重传。</p><h2 id="交换机的包转发操作">交换机的包转发操作</h2><ol><li>**交换根据地址表进行转发 **</li></ol><p>​交换机的设计是将网络包原样转发到目的地， 图 3.7 就是它的内部结构。  交换机端口的 MAC 模块不具有 MAC 地址。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024171445298.png" alt="image-20201024171445298"></p><p>​交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。</p><ol start="2"><li><strong>MAC地址表的维护</strong></li></ol><p>​交换机在转发包的过程中， 还需要对 MAC 地址表的内容进行维护，维护操作分为两种。<br>​第一种是收到包时， 将发送方 MAC 地址以及其输入端口的号码写入MAC 地址表中。   另一种是删除地址表中某条记录的操作， 这是为了防止设备移动时产生问题。   综合来看， 为了防止终端设备移动产生问题， 只需要将一段时间不使用的过时记录从地址表中删除就可以了。</p><ol start="3"><li><strong>全双工模式可以同时进行发送和接收</strong></li></ol><p>​全双工模式是交换机特有的工作模式， 它可以同时进行发送和接收操作， 集线器不具备这样的特性。使用集线器时， 如果多台计算机同时发送信号， 信号就会在集线器内部混杂在一起， 进而无法使用， 这种现象称为碰撞， 是以太网的一个重要特征。 不过， 只要不用集线器， 就不会发生碰撞。</p><p>​而使用双绞线时， 发送和接收的信号线是各自独立的 A， 因此在双绞线中信号不会发生碰撞。 网线连接的另一端， 即交换机端口和网卡的 PHY（ MAU） 模块以及 MAC 模块， 其内部发送和接收电路也是各自独立的， 信号也不会发生碰撞。 因此， 只要不用集线器， 就可以避免信号碰撞了。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024200415817.png" alt="image-20201024200415817"></p><h2 id="路由器的包转发操作">路由器的包转发操作</h2><ol><li>**路由器的基本知识  **</li></ol><p>​网络包经过集线器和交换机之后， 现在到达了路由器， 并在此被转发到下一个路由器。   这一步转发的工作原理和交换机类似， 也是通过查表判断包转发的目标。 不过在具体的操作过程上， 路由器和交换机是有区别的。 因为路由器是基于 IP 设计的， 而交换机是基于以太网设计的</p><p>​路由器的内部结构如图 3.12 所示。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024200653533.png" alt="image-20201024200653533"></p><p>​路由器在转发包时， 首先会通过端口将发过来的包接收进来， 这一步的工作过程取决于端口对应的通信技术。   接下来， 转发模块会根据接收到的包的 IP 头部中记录的接收方 IP 地址， 在路由表中进行查询， 以此判断转发目标。 然后， 转发模块将包转移到转发目标对应的端口， 端口再按照硬件的规则将包发送出去， 也就是转发模块委托端口模块将包发送出去的意思。  路由器的各个端口都具有 MAC 地址和 IP 地址。</p><ol start="2"><li><strong>路由表中的信息</strong></li></ol><p>​在“查表判断转发目标” 这一点上， 路由器和交换机的大体思路是类似的。路由器中的表叫作路由表， 其中包含的信息如图 3.13 所示。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024201023632.png" alt="image-20201024201023632"></p><p>​交换机是通过 MAC 头部中的接收方 MAC 地址来判断转发目标的， 而路由器则是根据 IP 头部中的 IP 地址来判断的。   交换机在地址表中只匹配完全一致的记录， 而路由器则会忽略主机号部分， 只匹配网络号部分。   打个比方， 路由器在转发包的时候只看接收方地址属于哪个区，×× 区发往这一边，×× 区发往那一边。</p><ol start="3"><li><strong>路由器的包接收操作</strong></li></ol><p>​路由器的端口有各种不同的类型， 这里我们只介绍以太网端口是如何接收包的。   首先， 信号到达网线接口部分， 其中的 PHY（ MAU） 模块和 MAC 模块将信号转换为数字信息， 然后通过包末尾的 FCS 进行错误校验， 如果没问题则检查 MAC 头部中的接收方 MAC 地址， 看看是不是发给自己的包，如果是就放到接收缓冲区中， 否则就丢弃这个包。</p><p>​完成包接收操作之后， 路由器就会丢弃包开头的 MAC 头部。 MAC 头部的作用就是将包送达路由器， 其中的接收方 MAC 地址就是路由器端口的 MAC 地址。   接下来， 路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。  如果在路由表中无法找到匹配的记录， 路由器会丢弃这个包， 并通过ICMPA （Internet Control Message Protocol， Internet 控制报文协议  ）消息告知发送方。  路由表中子网掩码为 0.0.0.0 的记录表示“默认路由”。</p><ol start="4"><li><strong>通过分片功能拆分大网络包</strong></li></ol><p>​不同的线路和局域网类型各自能传输的最大包长度也不同， 因此输出端口的最大包长度可能会小于输入端口。  遇到这种情况， 可以使用 IP 协议中定义的<strong>分片功能</strong>对包进行拆分， 缩短每个包的长度。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024201847139.png" alt="image-20201024201847139"></p><p>​如果查询标志字段发现不能分片， 那么就只能丢弃这个包， 并通过ICMP 消息通知发送方。 否则， 就可以按照输出端口 MTU 对数据进行依次拆分了。</p><p>​路由器判断下一个转发目标的方法如下。<br>● 如果路由表的网关列内容为 IP 地址，则该地址就是下一个转发目标。<br>● 如果路由表的网关列内容为空，则 IP 头部中的接收方 IP 地址就是下一个转发目标。</p><ol start="5"><li><strong>路由器与交换机的关系</strong></li></ol><p>​计算机在发送网络包时， 或者是路由器在转发网络包时， 都需要在前面加上 MAC 头部。   准确的说法应该是将 IP 包装进以太网包的数据部分中。  路由器是基于 IP 设计的， 而交换机是基于以太网设计的， 因此 IP 与以太网的关系也就是路由器与交换机的关系。  换句话说， 路由器将包的传输工作委托给交换机来进行。</p><p>​IP 本身不负责包的传输， 而是委托各种通信技术将包传输到下一个路由器， 这样的设计是有重要意义的， 即可以根据需要灵活运用各种通信技术， 这也是 IP 的最大特点。</p><h2 id="路由器的附加功能">路由器的附加功能</h2><ol><li><strong>通过地址转换有效利用 IP 地址</strong></li></ol><p>​所谓地址， 就是用来识别每一台设备的标志， 因此每台设备都应该有一个唯一不重复的地址。  互联网原本是这样设计的， 但进入 20 世纪 90 年代之后， 互联网逐步向公众普及， 接入互联网的设备数量也快速增长， 如此一来， 情况就发生了变化。</p><p>​因此需要设置一定的规则， 规定某些地址是用于内网的，这些地址叫作私有地址， 而原来的固定地址则叫作公有地址。  私有地址的规则其实并不复杂， 在内网中可用作私有地址的范围仅限以下这些。<br>10.0.0.0 ～ 10.255.255.255<br>172.16.0.0 ～ 172.31.255.255<br>192.168.0.0 ～ 192.168.255.255<br>​在制定私有地址规则时， 这些地址属于公有地址中还没有分配的范围。换句话说， 私有地址本身并没有什么特别的结构， 只不过是将公有地址中没分配的一部分拿出来规定只能在内网使用它们而已。</p><p>​当公司内网和互联网连接的时候， 需要采用图 3.17 这样的结构， 即将公司内网分成两个部分， 一部分是对互联网开放的服务器， 另一部分是公司内部设备。 其中对互联网开放的部分分配<strong>公有地址</strong>， 可以和互联网直接进行通信；内网部分则分配<strong>私有地址</strong>， 内网中的设备不能和互联网直接收发网络包， 而是通过一种特别的机制进行连接， 这个机制就叫<strong>地址转换</strong>。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024210259370.png" alt="image-20201024210259370"></p><ol start="2"><li><strong>地址转换的基本原理</strong></li></ol><p>​地址转换的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号进行改写，这里的端口号指的是 TCP 和 UDP 的端口号，不是路由器和集线器连接网线的那个端口。</p><p>​TCP 连接操作的第一个包被转发到互联网时， 会像图 3.18 这样， 将发送方 IP 地址从私有地址改写成公有地址。 这里使用的公有地址是地址转换设备的互联网接入端口的地址。 与此同时， 端口号也需要进行改写， 地址转换设备会随机选择一个空闲的端口。 然后， 改写前的私有地址和端口号， 以及改写后的公有地址和端口号， 会作为一组相对应的记录保存在地址转换设备内部的一张表中。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201024210524154.png" alt="image-20201024210524154"></p><p>​改写发送方 IP 地址和端口号之后， 包就被发往互联网， 最终到达服务器， 然后服务器会返回一个包。 地址转换设备会从地址对应表中通过公有地址和端口号找到相对应的私有地址和端口号， 并改写接收方信息， 然后将包发给公司内网，这样包就能够到达原始的发送方了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;局域网&lt;/strong&gt;：局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。局域网通常是分布在一个有限地理范围内的网络系统，一般所涉及的地理范围只有几公里。局域网专用性非常强，具有比较稳定和规范的拓扑结构。&lt;/p&gt;
&lt;p&gt;**双绞线：**双绞线是一种传输介质，由二根包着绝缘材料的细铜线按一定的比率相互缠绕而成。二根线双绞缠绕，改变了电缆原有的电子特性，不但可以减少自身的串扰，也可以最大程度上防止其它电缆上的信号对这对线缆上的干扰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mp.sohu.com/upload/20170526/d3113b0b7179436faced571f4ed2a3ee.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端笔记" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络是如何连接的 第二章 用电信号传输TCP-IP数据</title>
    <link href="http://example.com/2020/10/24/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%94%A8%E7%94%B5%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93TCP-IP%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2020/10/24/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%94%A8%E7%94%B5%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93TCP-IP%E6%95%B0%E6%8D%AE/</id>
    <published>2020-10-24T07:46:00.000Z</published>
    <updated>2020-10-27T12:34:53.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释">名词解释</h2><p><strong>套接字</strong>：即<a href="http://c.biancheng.net/socket/">socket</a>，为通信的端点。每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。</p><p>套接字与socket可以划等号。</p><p><strong>TCP/IP</strong>：TCP/IP 指传输控制协议/网际协议 (<em>T</em>ransmission <em>C</em>ontrol <em>P</em>rotocol / <em>I</em>nternet <em>P</em>rotocol)。它定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。 **TCP **用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。**IP **用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><a id="more"></a><p><strong>TCP/IP协议栈</strong>：协议栈（Protocol stack），又称协议堆叠。是一系列网络协议的总和。TCP/IP协议栈，<strong>又称TCP/IP</strong>，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是<strong>应用层、传输层、网络层和链路层</strong>，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p><p>协议栈的内部如图 2.1 所示， 分为几个部分， 分别承担不同的功能。 这张图中的上下关系是有一定规则的， 上面的部分会向下面的部分委派工作， 下面的部分接受委派的工作并实际执行。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019201116762.png" alt="image-20201019201116762"></p><p><strong>IP地址</strong>：ip（Internet Protocol）是指网络之间互联的协议。IP 地址（Internet Protocol Address）是互联网协议特有的一种地址，它是 IP 协议提供的一种统一的地址格式。</p><p><strong>MAC地址</strong>：符合 IEEE 规格的局域网设备都使用同一格式的地址，这种地址被称为 MAC 地址。</p><p>**IP地址和MAC地址：**在单个局域网网段中，计算机与计算机之间可以使用网络访问层提供的 MAC 地址进行通信。如果在路由式网络中，计算机之间进行通信就不能利用 MAC 地址实现数据传输了：因为 MAC 地址不能跨路由接口运行；即使强行实现跨越，使用 MAC 地址传输数据也是非常麻烦的。这是由于内置在网卡里的固定 MAC 地址不能在地址空间上引入逻辑结构，使其无法具备真正的地址来表示国家、省、市、区、街道、路、号这类层次。因此，要进行数据传输，必须使用一种逻辑化、层次化的寻址方案对网络进行组织，这就是 IP 地址。</p><p><strong>知识拓展</strong>：<a href="https://www.zhihu.com/question/21546408/answer/53576595">有了 IP 地址，为什么还要用 MAC 地址？</a></p><p><strong>端口号</strong>：“端口”可以认为是计算机与外界通信交流的出口。一个IP地址可以有65 536（即256*256）个端口。端口是通过端口号来标记的，端口号只有整数，范围是0~65535）。</p><p><strong>端口号比喻</strong>：一个主机是一栋楼，这栋楼的名字是这个主机的ip地址，这栋楼有65536个房间，每个房间供一个进程(程序)使用;假如说QQ使用10086号房间，那么从你好友那儿过来的信息是要去这栋楼10086号房间，意思就是好友发来的数据是由192.168.1.5这个主机的10086号端口接受，供给QQ这个程序使用。每个主机的端口总共有65536个，这个是固定的。假如说你写了一个程序，而且它需要通过网络去跟另一个主机上的一个程序通信，那么这时候你需要开一个房间给这个程序使用，这个是写在代码里的，可以指定一个房间（端口），也可以设置成让它自己随便找个房间(端口)使用。</p><p><strong>ARP</strong>：Address Resolution Protocol，即地址解析协议。ARP 利用广播对所有设备，根据IP地址询问MAC地址，以此找到与IP地址对应的MAC地址。</p><h2 id="前言">前言</h2><p>​本章主要将讲解操作系统中的协议栈是如何处理数据发送请求的，并描述了通过套接字收发数据的整个过程。 所以，需要对协议栈，套接字两个名词有一个概念。</p><p>​套接字: 即<a href="http://c.biancheng.net/socket/">socket</a>，为通信的端点，每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。（反复理解套接字。。）</p><p>一个常见的问题：<a href="https://www.zhihu.com/question/21383903">Socket为什么要翻译成套接字？</a></p><p>在网上看到把socket翻译成套接字比较赞的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套接字的翻译逻辑我想应该是这样的： 两台计算机通过socket想插头与插座那样连接在一起，故称”套接“ 应用程序通过类似文件标识符的一个标识字对socket进行操作，故称”字“</span><br></pre></td></tr></table></figure><p>下面开始本章内容。</p><h2 id="创建套接字">创建套接字</h2><ol><li><strong>协议栈与套接字</strong></li></ol><p>​在协议栈内部有一块用于存放控制信息的内存空间， 这里记录了用于控制通信操作的控制信息， 例如通信对象的 IP 地址、 端口号、 通信操作的进行状态等。我们可以说这些控制信息就是<font color=red>套接字</font>， 或者说存放控制信息的内存空间就是<font color=red>套接字</font>。协议栈在执行操作时需要参阅这些控制信息。 总结下来就是：协议栈是根据套接字中记录的控制信息来工作的。</p><p>​在 Windows 中可以用 netstat 命令显示套接字内容 ：</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019204558297.png" alt="image-20201019204558297"></p><ol start="2"><li><strong>调用套接字</strong></li></ol><p>​<strong>应用程序</strong>通过 Socket 库调用 socket来申请创建套接字， <strong>协议栈</strong>根据应用程序的申请执行创建套接字的操作。创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。</p><h2 id="连接服务器">连接服务器</h2><p>​创建套接字之后， 应用程序（ 浏览器） 就会调用 connect， 随后协议栈<br>会将本地的套接字与服务器的套接字进行连接。</p><ol><li>**负责保存控制信息的头部 **</li></ol><p>​控制信息大体上可以分为两类。</p><p>​（1）头部中记录的信息</p><p>​（2）套接字（协议栈中的内存空间）中记录的信息</p><p>​第一类是客户端和服务器相互联络时交换的控制信息，这些信息在 TCP 协议的规格中进行了定义。表 2.1 中的这些字段就是 TCP 规格中定义的控制信息 A。 这些字段是固定的， 在连接、 收发、断开等各个阶段中， 每次客户端和服务器之间进行通信时， 都需要提供这些控制信息。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019211155601.png" alt="image-20201019211155601"></p><p>​这些控制信息位于网络包的开头， 因此被称为头部。此外， 以太网和 IP 协议也有自己的控制信息， 这些信息也叫头部，为了避免各种不同的头部发生混淆， 我们一般会记作 TCP 头部、 以太网头部、 IP 头部。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019211444388.png" alt="image-20201019211444388"></p><p>​第二类就是保存在套接字中， 用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里， 还有收发数据操作的执行状态等信息也会保存在这里， 协议栈会根据这些信息来执行每一步的操作。</p><ol start="2"><li><strong>连接操作的过程</strong></li></ol><p>​连接操作的第一步是在 TCP 模块处创建表示连接控制信息的头部。 通过TCP 头部中的发送方和接收方端口号可以找到要连接的套接字。  客户端头部的控制信息有SYN（设为1时表示连接）、序号、窗口大小。</p><p>​客户端TCP头部创建好后，将信息传递给IP模块，委托其进行发送。发送给服务器的IP模块负责接收，并传给TCP模块，之后 TCP 模块会返回响应， 这个过程和客户端一样， 需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特，  此外， 在返回响应时还需要将 ACK 控制位设为1， 这表示已经接收到相应的网络包。</p><p>​然后， 网络包就会返回到客户端， 通过 IP 模块到达 TCP 模块， 并通过 TCP 头部的信息确认连接服务器的操作是否成功。 如果 SYN 为 1 则表示连接成功， 这时会向套接字中写入服务器的 IP 地址、 端口号等信息， 同时还会将状态改为连接完毕。</p><h2 id="收发数据">收发数据</h2><ol><li>**将 HTTP 请求消息交给协议栈  **</li></ol><p>​数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的。协议栈会根据一个叫作 MTUA 的参数来进行判断。 MTU 表示一个网络包的最大长度， 在以太网中一般是 1500 字节（ 图 2.5）。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019212553083.png" alt="image-20201019212553083"></p><p>为了避免发送大量小包的问题，设置从应用程序收到的数据长度超过或者接近 MSS 时再发送出去 。</p><p>2.<strong>对较大数据进行拆分</strong></p><p>​HTTP 请求消息一般不会很长， 一个网络包就能装得下， 但如果其中要提交表单数据， 长度就可能超过一个网络包所能容纳的数据量。 这种情况下， 发送缓冲区中的数据就会超过 MSS 的长度，发送缓冲区中的数据会被以 MSS 长度为单位进行拆分， 拆分出来的每块数据前面都会加上 TCP 头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019212835502.png" alt="image-20201019212835502"></p><ol start="3"><li>**使用 ACK 号确认网络包已收到  **</li></ol><p>​网络包装好数据并发往服务器之后， 数据发送操作并没有结束。 TCP 具备确认对方是否成功收到网络包， 以及当对方没收到时进行重发的功能。这部分功能通过序号和ACK号来实现。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019213034346.png" alt="image-20201019213034346"></p><p>​TCP 采用这样的方式确认对方是否收到了数据， 在得到对方确认之前， 发送过的包都会保存在发送缓冲区中。 如果对方没有返回某些包对应的 ACK 号， 那么就重新发送这些包。</p><p>4.**接收 HTTP 响应消息  **</p><p>​发送 HTTP 请求消息后， 接下来还需要等待 Web 服务器返回响应消息。浏览器在委托协议栈发送请求消息之后， 会调用 read 程序来获取响应消息， 然后控制流程会通过 read 转移到协议栈。  协议栈会检查收到的数据块和 TCP 头部的内容， 判断是否有数据丢失， 如果没有问题则返回 ACK 号。 然后，协议栈将数据块暂存到接收缓冲区中， 并将数据块按顺序连接起来还原出原始的数据， 最后将数据交给应用程序。</p><h2 id="从服务器断开并删除套接字">从服务器断开并删除套接字</h2><ol><li>**断开连接  **</li></ol><p>​收发数据结束后，服务器一方的应用程序会调用 Socket 库的 close 程序。然后， 服务器的协议栈会生成包含断开信息的 TCP 头部(将控制位中的 FIN 比特设为 1)。接下来， 协议栈会委托 IP 模块向客户端发送数据，客户端收到服务器发来的 FIN 为 1 的 TCP 头部时，协议栈会将自己的套接字标记为进入断开操作状态。 然后客户端会向服务器返回一个 ACK 号。</p><p>​收到服务器返回的数据后， 客户端的操作也就随之结束了。 因此， 客户端应用程序会调用 close 来结束数据收发操作， 这时客户端的协议栈也会和服务器一样， 生成一个 FIN 比特为 1 的 TCP 包， 然后委托 IP 模块发送给服务器。 一段时间之后， 服务器就会返回ACK 号。 到这里， 客户端和服务器的通信就全部结束了。</p><ol start="2"><li>**删除套接字 **</li></ol><p>​服务器的通信结束之后， 用来通信的套接字也就不会再使用了， 这时就可以删除这个套接字了。 不过， 套接字并不会立即被删除， 而是会等待一段时间之后再被删除（等待这段时间是为了防止误操作 ）。 断开的操作顺序如下：</p><p>（ 1） 客户端发送 FIN<br>（ 2） 服务器返回 ACK 号<br>（ 3） 服务器发送 FIN<br>（ 4） 客户端返回 ACK 号</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201019214456351.png" alt="image-20201019214456351"></p><h2 id="IP-与以太网的包收发操作">IP 与以太网的包收发操作</h2><ol><li><strong>包的基本知识</strong></li></ol><p>​包是由头部和数据两部分构成的，头部包含目的地址等控制信息， 大家可以把它理解为快递包裹的面单； 头部后面就是委托方要发送给对方的数据， 也就相当于快递包裹里的货物。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020094059569.png" alt="image-20201020094059569"></p><ol start="2"><li><strong>包的传输</strong></li></ol><p>​TCP 模块在执行连接、 收发、 断开等各阶段操作时， 都需要委托 IP 模块将数据封装成包发送给通信对象。</p><p>​发送方的网络设备会负责创建包， 创建包的过程就是生成含有正确控制信息的头部， 然后再附加上要发送的数据。  接下来， 包会被发往 最近的网络转发设备。 当到达最近的转发设备之后， 转发设备会根据头部中的信息判断接下来应该发往哪里。 这个过程需要用到一张表， 这张表里面记录了每一个地址对应的发送方向， 也就是按照头部里记录的目的地址在表里进行查询， 并根据查到的信息判断接下来应该发往哪个方向。</p><p>​网络中有路由器和集线器两种不同的转发设备， 它们在传输网络包时有<br>着各自的分工：</p><p>​（1） 路由器根据目标地址判断下一个路由器的位置<br>​（2） 集线器在子网中将网络包传输到下一个路由</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020094901908.png" alt="image-20201020094901908"></p><p>​为了判断包接下来应该向什么地方传输， 集线器里有一张表（ 用于以太网协议的表）， 可根据以太网头部中记录的目的地信息查出相应的传输方向。实际上， 集线器是按照以太网规则传输包的设备， 而路由器是按照 IP规则传输包的设备， 因此我们也可以作如下理解。<br>​（1） IP 协议根据目标地址判断下一个 IP 转发设备的位置（IP头部）<br>​（2） 子网中的以太网协议将包传输到下一个转发设备（MAC头部）</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020094827050.png" alt="image-20201020094827050"></p><p>​包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作，与此同时，TCP 模块还需要指定通信对象的 IP 地址， 也就是需要写清楚“将什么内容发给谁”。IP 模块会将包的内容当作一整块数据， 在前面加上包含控制信息的头部，即包含IP地址的IP头部和包含MAC地址的MAC头部。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020095453300.png" alt="image-20201020095453300"></p><p>​封装好的包会被交给网络硬件（网卡)。 传递给网卡的网络包是由一连串 0 和 1 组成的数字信息， 网卡会将这些数字信息转换为电信号或光信号， 并通过网线（ 或光纤） 发送出去， 然后这些信号就会到达集线器、 路由器等转发设备， 再由转发设备一步一步地送达接收方。</p><ol start="3"><li>**IP 头部  **</li></ol><p>​IP 头部包含的内容如表 2.2 所示， 其中最重要的内容就是 IP 地址， 它表示这个包应该发到哪里去。 这个地址是由 TCP 模块告知的， 而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的， 因此这个地址的最初来源就是应用程序。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020095741948.png" alt="image-20201020095741948"></p><ol start="4"><li>**MAC 头部  **</li></ol><p>​生成了 IP 头部之后， 接下来 IP 模块还需要在 IP 头部的前面加上MAC 头部（ 表 2.3）。 <font color=red>IP 头部</font>中的接收方 IP 地址表示网络包的目的地， 通过这个地址我们就可以判断要将包发到哪里， 但在<font color=red>以太网</font>的世界中， TCP/IP 的这个思路是行不通的。 以太网在判断网络包目的地时和 TCP/IP 的方式不同， 因此必须采用相匹配的方式才能在以太网中将包发往目的地， 而MAC 头部就是干这个用的。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020100126667.png" alt="image-20201020100126667"></p><p>​查询 MAC 地址需要使用 ARP(Address Resolution Protocol)，即地址解析协议。在以太网中， 有一种叫作广播的方法， 可以把包发给连接在同一以太网中的所有设备。 ARP 就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？ 请把你的 MAC 地址告诉我。” 然后就会有人回答：“这个 IP 地址是我的， 我的 MAC 地址是××××。”  即，与接收者地址匹配的设备接收这个包， 其他的设备则丢弃这个包。</p><p>​如果对方和自己处于同一个子网中， 那么通过上面的操作就可以得到对方的 MAC 地址。 然后将这个 MAC 地址写入 MAC 头部。</p><ol start="5"><li>**给网络包再加 3 个控制数据    **</li></ol><p>​IP 生成的网络包只是存放在内存中的一串数字信息， 没有办法直接发送给对方。 因此， 我们需要将数字信息转换为电或光信号， 才能在网线上传输。负责执行这一操作的是网卡，网卡的内部结构如图 2.23 所示。 网卡的 ROM 中保存着全世界唯一的 MAC 地址， 这是在生产网卡时写入的， 将这个值读出之后就可以对 MAC 模块进行设置， MAC 模块就知道自己对应的 MAC 地址了。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020101417720.png" alt="image-20201020101417720"></p><pre><code>但网卡也无法单独工作， 要控制网卡还需要网卡驱动程序。网卡驱动从 IP 模块获取包之后， 会将其复制到网卡内的缓冲区中， 然后向MAC 模块发送发送包的命令。   MAC 模块会将包从缓冲区中取出， 并在开头加上报头和起始帧分界符， 在末尾加上用于检测错误的帧校验序列（ 图 2.24）。报头是一串像 10101010…这样 1 和 0 交替出现的比特序列， 长度为 56比特， 它的作用是确定包的读取时机，起始帧分界符用来表示包起始位置的标记。        </code></pre><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020102117501.png" alt="image-20201020102117501"></p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020102248916.png" alt="image-20201020102248916"></p><p>​网络包末尾的 FCS（ 帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、 数据错误， 它是一串 32 比特的序列。在包传输过程中， 如果受到噪声的干扰而导致其中的数据发生了变化， 那么接收方计算出的 FCS 和发送方计算出的 FCS 就会不同， 这样我们就可以判断出数据有没有错误。</p><p>​加上报头、 起始帧分界符和 FCS 之后， 我们就可以将包通过网线发送出去了。发送信号的操作分为两种， 一种是使用集线器的半双工模式， 另一种是使用交换机的全双工模式。发送和接收同时并行的方式叫作“全双工”，相对地，某一时刻只能进行发送或接收其中一种操作的叫作“半双工”。</p><p>6.<strong>接收返回包</strong></p><p>​假设 Web 服务器返回了一个网络包，   网卡驱动会将其交给 TCP/IP 协议栈来进行处理。 接下来就轮到 IP 模块先开始工作了， 第一步是检查 IP 头部， 确认格式是否正确。 如果格式没有问题， 下一步就是查看接收方 IP 地址。 如果接收网络包的设备是一台 Windows 客户端计算机， 那么服务器返回的包的接收方 IP 地址应该与客户端网卡的地址一致，检查确认之后我们就可以接收这个包了。</p><p>​网线和局域网中只能传输小包， 因此需要将大的包切分成多个小包。 如果接收到的包是经过分片的， 那么 IP 模块会将它们还原成原始的包。 分片的包会在 IP 头部的标志字段中进行标记，当收到分片的包时， IP 模块会将其暂存在内部的内存空间中， 然后等待 IP头部中具有相同 ID 的包全部到达， 这是因为同一个包的所有分片都具有相同的 ID。 此外， IP 头部还有一个分片偏移量（ fragment offset） 字段， 它表示当前分片在整个包中所处的位置。 根据这些信息， 在所有分片全部收到之后， 就可以将它们还原成原始的包， 这个操作叫作分片重组。</p><p>​到这里， IP 模块的工作就结束了， 接下来包会被交给 TCP 模块。 TCP模块会根据 IP 头部中的接收方和发送方 IP 地址， 以及 TCP 头部中的接收方和发送方端口号来查找对应的套接字。 找到对应的套接字之后， 就可以根据套接字中记录的通信状态， 执行相应的操作了。</p><h2 id="UDP-协议的收发操作">UDP 协议的收发操作</h2><p>**不需要重发的数据用 UDP 发送更高效 **</p><p>​大多数的应用程序都像之前介绍的一样使用 TCP 协议来收发数据， 但当然也有例外。 有些应用程序不使用 TCP 协议， 而是使用 UDP 协议来收发数据。 向 DNS 服务器查询 IP 地址的时候我们用的也是 UDP 协议。   像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决， 这种场景中就可以用 UDP 来代替TCP 。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201020105822955.png" alt="image-20201020105822955"></p><p>接下来， 网络包会从计算机出来跑向集线器。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;套接字&lt;/strong&gt;：即&lt;a href=&quot;http://c.biancheng.net/socket/&quot;&gt;socket&lt;/a&gt;，为通信的端点。每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。&lt;/p&gt;
&lt;p&gt;套接字与socket可以划等号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP&lt;/strong&gt;：TCP/IP 指传输控制协议/网际协议 (&lt;em&gt;T&lt;/em&gt;ransmission &lt;em&gt;C&lt;/em&gt;ontrol &lt;em&gt;P&lt;/em&gt;rotocol / &lt;em&gt;I&lt;/em&gt;nternet &lt;em&gt;P&lt;/em&gt;rotocol)。它定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。 **TCP **用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。**IP **用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端笔记" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络是如何连接的 第一章 浏览器生成消息</title>
    <link href="http://example.com/2020/10/24/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF/"/>
    <id>http://example.com/2020/10/24/%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF/</id>
    <published>2020-10-24T07:14:00.000Z</published>
    <updated>2020-10-27T12:34:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释">名词解释</h2><p><strong>URL</strong>：Uniform Resource Locator，统一资源定位符。  又叫网址 ， 指以 http:// 开头的那一串东西 。</p><p><strong>URI</strong>： Uniform Resource Identifier，统一资源标识符。  客户端会向服务器发送请求消息。 请求消息中包含的内容是“对什么” 和“进行怎样的操作” 两个部分。 其中相当于“对什么” 的部分称为 URI。相当于接下来“进行怎样的操作” 的部分称为方法，包括常用的GET、POST方法，和其他方法，如HEAD、OPTIONS、DELETE等。</p><p><strong>HTTP协议</strong>：HTTP协议是<strong>超文本传输协议</strong>的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。即，HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤 。</p><p><strong>HTML</strong>：HTML 指超文本标记语言 (Hyper Text Markup Language)， 是用来描述网页的一种语言。HTML 不是一种编程语言，而是一种<strong>标记语言</strong>，HTML 使用标记标签来描述网页。</p><a id="more"></a><p><strong>知识拓展</strong>：<a href="https://www.zhihu.com/question/20377296">HTML 是什么？</a></p><p><strong>域名</strong>：Domain Name，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。</p><p><strong>域名和URL的区别</strong>：</p><p>以 <a href="http://mail.163.com/index.html%E4%B8%BA%E4%BE%8B%EF%BC%9A">http://mail.163.com/index.html为例：</a></p><p>(1) http:// 是<font color=red>协议</font>，也就是HTTP超文本传输协议，也就是网页在网上传输的协议。</p><p>(2) mai 是<font color=red>服务器名</font>，代表着是一个邮箱服务器，所以是mail.</p><p>(3) <a href="http://163.com">163.com</a> 是<font color=red>域名</font>，是用来定位网站的独一无二的名字。</p><p>(4) <a href="http://mail.163.com">mail.163.com</a> 是<font color=red>网站名</font>，由服务器名+域名组成。</p><p>(5) “/” 指根目录，也就是说，通过网站名找到服务器，然后在服务器存放网页的根目录</p><ol start="6"><li>index.html：这个是根目录下的默认网页（大部分的默认网页都是index.html）</li></ol><p>(7) <a href="http://mail.163.com/index.html">http://mail.163.com/index.html</a> 则是<font color='red'>URL</font>，统一资源定位符，全球性地址，用于定位网上的资源。</p><p><strong>DNS</strong>：Domain Name System，网域名称系统。DNS是一个域名系统，是万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>IP地址</strong>：IP 地址是一串 32 比特的数字，按照 8 比特（ 1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。 这组数字指定了设备的网络号和主机号。其中， 网络对应的号码是分配给整个子网的， 而主机号对应的号码是分配给子网中的计算机的， 这就是网络中的地址。  在组建网络时，用户可以用子网掩码决定网络号和主机号之间的分配关系。</p><p><strong>子网掩码</strong>：是一 串与 IP 地址长度相同的 32 比特数字，其左边一半都是 1，右边一半都是0。其中，子网掩码为 1 的部分表示网络号， 子网掩码为 0 的部分表示主机号。此外，主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义。 主机号部分全部为 0 代表整个子网而不是子网中的某台设备；主机号部分全部为 1 代表向子网上所有设备发送包 即广播。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016174501413.png" alt="image-20201016174501413"><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016174511048.png" alt="image-20201016174511048"></p><h2 id="浏览器生成消息的过程">浏览器生成消息的过程</h2><p><strong>客户端生成HTTP请求消息</strong>  → <strong>向DNS服务器查询Web服务器的IP地址</strong>  → <strong>寻找相应的 DNS 服务器并获取 IP 地址</strong></p><h3 id="客户端生成HTTP请求消息">客户端生成HTTP请求消息</h3><ol><li><strong>url组成</strong>：</li></ol><p><img src="D:\文档\电子书笔记\typora-user-images\image-20201016171631680.png" alt="image-20201016171631680"  /><img src="D:\文档\电子书笔记\typora-user-images\image-20201016171727882.png" alt="image-20201016171727882"  /></p><ol start="2"><li><strong>浏览器解析url</strong></li></ol><p>​(1). 客户端会根据HTTP协议，向服务器发送请求消息。请求消息由请求行、请求头、消息体组成。</p><p>​请求消息中包含的内容是“对什么” 和“进行怎样的操作” 两个部分。其中相当于“对什么” 的部分称为 URI，相当于接下来“进行怎样的操作” 的部分称为方法。收到请求消息之后，Web 服务器会对其中的内容进行解析，通过 URI 和方法来判断“对什么”，“进行怎样的操作”，并根据这些要求来完成自己的工作，然后将结果存放在响应消息中，响应消息由状态行、消息头、消息体组成。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016173455423.png" alt="image-20201016173455423"></p><p>​(2).在响应消息的开头有一个状态码， 它用来表示操作的执行结果是成功还是发生了错误。状态码后面就是头字段和网页数据。 响应消息会被发送回客户端， 客户端收到之后 浏览器会从消息中读出所需的数据并显示在屏幕上。 到这里 HTTP 的整个工作就完成了。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016172745271.png" alt="image-20201016172745271"></p><p>​(3).由于每条请求消息中只能写 1 个 URI， 所以每次只能获取 1 个文件， 如果需要获取多个文件， 必须对每个文件单独发送 1 条请求。 比如 1个网页中包含 3 张图片， 那么获取网页加上获取图片， 一共需要向 Web 服务器发送 4 条请求。</p><h3 id="向DNS服务器查询Web服务器的IP地址">向DNS服务器查询Web服务器的IP地址</h3><p>​<strong>1. 域名和 IP 地址</strong></p><p>​互联网和公司内部的局域网都是基于 TCP/IP 的思路来设计的，而TCP/IP 网络是通过 IP 地址来确定通信对象的， 因此不知道 IP 地址就无法将消息发送给对方。因此，在委托操作系统发送消息时，必须要先查询好对方的 IP 地址。</p><p>​现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。 这个机制就是 DNS。</p><p>​<strong>2. 通过 DNS 查询 IP 地址</strong></p><p>​向 DNS 服务器发出查询， 也就是向 DNS 服务器发送查询消息， 并接收服务器返回的响应消息。 换句话说， 对于 DNS 服务器， 我们的计算机上一定有相应的 DNS 客户端， 而相当于 DNS 客户端的部分称为 DNS 解析器， 或者简称解析器。 通过 DNS 查询 IP 地址的操作称为域名解析， 因此负责执行解析（ resolution） 这一操作的就叫解析器（ resolver） 了 。</p><p>​解析器实际上是一段程序， 它包含在操作系统的 Socket 库中 ，Socket 库是用于调用网络功能的程序组件集合。调用解析器后， 解析器会向 DNS 服务器发送查询消息， 然后 DNS 服务器会返回响应消息。 响应消息中包含查询到的 IP 地址， 解析器会取出 IP 地址， 并将其写入浏览器指定的内存地址中。</p><p>​顺带一提， 向 DNS 服务器发送消息时， 我们当然也需要知道 DNS 服 务器的 IP 地址。 只不过这个 IP 地址是作为 TCP/IP 的一个设置项目事先设 置好的， 不需要再去查询了。 不同的操作系统中 TCP/IP 的设置方法也有差 异， Windows 中的设置如图 1.13 所示， 解析器会根据这里设置的 DNS 服 务器 IP 地址来发送消息。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016200121611.png" alt="image-20201016200121611"></p><p>​**3. 寻找相应的 DNS 服务器并获取 IP 地址    **</p><p>​DNS 服务器中的所有信息都是按照域名以分层次的结构来保存 的。 层次结构这个词听起来可能有点不容易懂， 其实就类似于公司中的事 业集团、 部门、 科室这样的结构。 层次结构能够帮助我们更好地管理大量 的信息。DNS 中的域名都是用句点来分隔的， 比如 <a href="http://www.lab.glasscom.com">www.lab.glasscom.com</a>， 这里的句点代表了不同层次之间的界限，在域名中，越靠右的位置表示其层级越高， 比如 <a href="http://www.lab.glasscom.com">www.lab.glasscom.com</a> 这个域名如果按照公司 里的组织结构来说， 大概就是“com 事业集团 glasscom 部 lab 科的 www” 这样。 其中，相当于一个层级的部分称为域。 因此， com 域的下一层是 glasscom 域，再下一层是 lab 域，再下面才是 www 这个名字。</p><p>​在前面的讲解中， 似乎 com、 jp 这些域（ 称为顶级域） 就是最顶层了，但在互联网中， com 和 jp 的上面还有一级域， 称为根域。 如果要明确表示根域， 应该像 <a href="http://www.lab.glasscom.com">www.lab.glasscom.com</a>. 这样在域名的最后再加上一个句点， 而这个最后的句点就代表根域。将根域的 DNS 服务器信息保 存在互联网中所有的 DNS 服务器中， 这样任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>​下面就来看一看DNS 服务器如何从上万台 DNS 服务器中找到目标服务器。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016205203153.png" alt="image-20201016205203153"></p><h3 id="委托协议栈发送消息">委托协议栈发送消息</h3><p>​发送数据是一系列操作相结合来实现的，和向 DNS 服务器查询 IP 地址的操作一样， 这里也需要使用 Socket 库中的程序组件。不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件。</p><p>收发数据的操作分为若干个阶段， 可以大致总结为以下 4 个：</p><p>（1） 创建套接字（ 创建套接字阶段）<br>（2） 将管道连接到服务器端的套接字上（ 连接阶段）<br>（3） 收发数据（ 通信阶段）<br>（4） 断开管道并删除套接字（ 断开阶段）</p><p>这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。使用 Socket 库来收发数据的操作过程如图 1.17 所示。</p><p><img src="D:%5C%E6%96%87%E6%A1%A3%5C%E7%94%B5%E5%AD%90%E4%B9%A6%E7%AC%94%E8%AE%B0%5Ctypora-user-images%5Cimage-20201016205809105.png" alt="image-20201016205809105"></p><ol><li><strong>创建套接字阶段</strong></li></ol><p>​首先， 服务器一方先创建套接字， 然后等待客户端向该套接字连接管道。  当服务器进入等待状态时， 客户端就可以连接管道了。</p><p>​客户端 调用 socket 之后， 控制流程会转移到 socket 内部并执行创建套接字的操作， 完成之后控制流程又会被移交回应用程序。套接字创建完成后， 协议栈会返回一个描述符， 应用程序会将收到的描述符存放在内存中。</p><p>​ 计算 机中会同时进行多个数据的通信操作，比如可以打开两个浏览器窗口， 同时访问两台 Web 服务器。这时，有两个数据收发操作在同时进行，也就需要创建两个不同的套接字。这个例子说明， 同一台计算机上可能同时存在多个套接字，在这样的情况下， 我们就需要一种方法来识别出某个特定的套接字， 这种方法就是描述符。</p><ol start="2"><li>**连接阶段：把管道接上去  **</li></ol><p>​委托协议栈将客户端创建的套接字与服务器那边的 套接字连接起来。应用程序通过调用 Socket 库中的名为 connect 的程序组 件来完成这一操作。这里的要点是当调用 connect 时，需要指定描述符、 服务器 IP 地址和端口号这 3 个参数。</p><p>​(1) 描述符：应用程序用来识别套接字的机制<br>​(2) IP 地址和端口号：客户端和服务器之间用来识别对方套接字的机制</p><p>​客户端在创建套接字时，协议栈会为这个套接 字随便分配一个端口号 。 接下来， 当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。描述符是用来在一台计算机内部识别套接字的机制， 而端口号是用来让通信的另一方能够识别出套接字的机制。其中，服务器上所使用的端口号是根据应用的种类事先规定好的，只要指定了事先规定好的端口号， 就可以连接到相应的服务器程序的套接字。</p><ol start="3"><li>**通信阶段：传递消息 **</li></ol><p>​当套接字连接起来之后，只要将数据送入套接字， 数据就会被发送到对方的套接字中。这个操作需要使用Socket 库 中的 write 程序组件。服务器执行接收操作后， 解析收到的数据内容，并执行相应的操作，向客户端返回响应消息。当消息返回后， 需要执行的是接收消息的操作。 接收消息的操作是通 过 Socket 库中的 read 程序组件委托协议栈来完成的</p><ol start="4"><li>**断开阶段：收发数据结束  **</li></ol><p>​浏览器收到数据之后， 收发数据的过程就结束了。 接下来， 调用 Socket 库的 close 程序组件进入断开阶段 最终， 连接在套接字之间的管道会被断开， 套接字本身也会被删除。</p><p>​这就是 HTTP 的工作过程。 HTTP 协议将 HTML 文档和图片都作为单独的对象来处理， 每获取一次数据， 就要执行一次连接、 发送请求消息、 接收响应消息、 断开的过程。 因此， 如果一个网页中包含很多张图片， 就必须重复进行很多次连接、 收发数据、 断开的操作。 对于同一台服务器来 说， 重复连接和断开显然是效率很低的， 因此后来人们又设计出了能够在 一次连接中收发多个请求和响应的方法。 在 HTTP 版本 1.1 中就可以使用这种方法， 在这种情况下， 当所有数据都请求完成后， 浏览器会主动触发断开连接的操作。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;URL&lt;/strong&gt;：Uniform Resource Locator，统一资源定位符。  又叫网址 ， 指以 http:// 开头的那一串东西 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI&lt;/strong&gt;： Uniform Resource Identifier，统一资源标识符。  客户端会向服务器发送请求消息。 请求消息中包含的内容是“对什么” 和“进行怎样的操作” 两个部分。 其中相当于“对什么” 的部分称为 URI。相当于接下来“进行怎样的操作” 的部分称为方法，包括常用的GET、POST方法，和其他方法，如HEAD、OPTIONS、DELETE等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议&lt;/strong&gt;：HTTP协议是&lt;strong&gt;超文本传输协议&lt;/strong&gt;的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。即，HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;：HTML 指超文本标记语言 (Hyper Text Markup Language)， 是用来描述网页的一种语言。HTML 不是一种编程语言，而是一种&lt;strong&gt;标记语言&lt;/strong&gt;，HTML 使用标记标签来描述网页。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端笔记" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编程书籍列表</title>
    <link href="http://example.com/2020/10/13/%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D/"/>
    <id>http://example.com/2020/10/13/%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D/</id>
    <published>2020-10-13T13:42:58.000Z</published>
    <updated>2020-10-13T13:43:43.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这篇文章主要总结了从网上搜集到的，和计算机编程相关的书籍，涉及计算机原理、数据结构、前端、后端。这里例举出的书籍都是还未读过的，读过的文章在后面会另写文章作为笔记和读后感。 整个学习框架有些庞大，希望能坚持下去！</p><a id="more"></a><h2 id="计算机基础">计算机基础</h2><p>《编码——隐匿在计算机软硬件背后的语言》</p><p>《计算机程序的构造和解释(SICP)》 ps：基于这本书，伯克利的一位教授搞了个教学网站 - <a href="https://link.zhihu.com/?target=http%3A//composingprograms.com/about.html">http://composingprograms.com/about.html</a>，用Python来教SICP，有兴趣可以去看看。</p><p>《代码大全 第2版》</p><h2 id="数据结构">数据结构</h2><p>《算法（第四版）》</p><p>《大话数据结构》</p><p>leetcode 刷题</p><p><a href="https://github.com/MisterBooo">Github上的图解算法</a></p><p><a href="https://link.zhihu.com/?target=http%3A//mooc.study.163.com/course/ZJU-1000033001%23/info">数据结构 - 网易云课堂</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.xuetangx.com/courses/course-v1%3ATsinghuaX%2B30240184X%2Bsp/about">数据结构-学堂在线慕课(MOOC)平台</a></p><h2 id="前端">前端</h2><p>阮一峰的 JavaScript 教程，<a href="https://wangdoc.com/javascript/">传送门</a></p><p>阮一峰的 ES6 教程,<a href="https://es6.ruanyifeng.com/">传送门</a></p><p>《JavaScript高级编程》</p><p>《CSS揭秘》</p><h2 id="相关">相关</h2><p>《编程大师访谈录》</p><p>《人件》</p><p>《梦断代码》</p><p>《编程人生：15位软件先驱访谈录》</p><p>《乔布斯传》</p><h2 id="参考网址">参考网址</h2><ol><li><a href="https://www.zhihu.com/question/369283077/answer/1006824219?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=647371984640675840&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn">我是一名普通一本的大一学生，想自学前端然后能去像阿里腾讯这样的地方工作吗？</a></li><li><a href="https://www.zhihu.com/question/21318658/answer/1268219135?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=647371984640675840&amp;utm_content=group1_Answer&amp;utm_campaign=shareopn">12月初，将<strong>图解算法</strong>项目放到了GitHub上面去，短短两天登上了 trending 版第一的位置，点击这了解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇文章主要总结了从网上搜集到的，和计算机编程相关的书籍，涉及计算机原理、数据结构、前端、后端。这里例举出的书籍都是还未读过的，读过的文章在后面会另写文章作为笔记和读后感。 整个学习框架有些庞大，希望能坚持下去！&lt;/p&gt;</summary>
    
    
    
    
    <category term="书籍推荐" scheme="http://example.com/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络</title>
    <link href="http://example.com/2020/10/13/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2020/10/13/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-10-13T07:29:22.000Z</published>
    <updated>2020-10-13T12:17:41.068Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://hackcv.com/2016/10/%E7%BF%BB%E8%AF%91-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%B4%E8%A7%82%E8%A7%A3%E9%87%8A/">原文地址</a></h1><h2 id="什么是卷积神经网络？为什么它们很重要？">什么是卷积神经网络？为什么它们很重要？</h2><p>卷积神经网络（ConvNets 或者 CNNs）属于神经网络的范畴，已经在诸如图像识别和分类的领域证明了其高效的能力。卷积神经网络可以成功识别人脸、物体和交通信号，从而为机器人和自动驾驶汽车提供视力。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5azE3Y3JwNGozMTVxMGZ0dHpyLmpwZw?x-oss-process=image/format,png" alt="图 1"></p><a id="more"></a><p>在上图中，卷积神经网络可以识别场景，也可以提供相关的标签，比如“桥梁”、“火车”和“网球”；而下图展示了卷积神经网络可以用来识别日常物体、人和动物。最近，卷积神经网络也在一些自然语言处理任务（比如语句分类）上面展示了良好的效果。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5azJtdjd3aGozMGtzMDdybjVyLmpwZw?x-oss-process=image/format,png" alt="图 2"></p><p>因此，卷积神经网络对于今天大多数的机器学习用户来说都是一个重要的工具。然而，理解卷积神经网络以及首次学习使用它们有时会很痛苦。那本篇博客的主要目的就是让我们对卷积神经网络如何处理图像有一个基本的了解。</p><p>如果你是神经网络的新手，我建议你阅读下<a href="https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/">这篇短小的多层感知器的教程</a>，在进一步阅读前对神经网络有一定的理解。在本篇博客中，多层感知器叫做“全连接层”。</p><h2 id="LeNet-架构-（1990s）">LeNet 架构 （1990s）</h2><p>LeNet 是推进深度学习领域发展的最早的卷积神经网络之一。经过多次成功迭代，到 1988 年，Yann LeCun 把这一先驱工作命名为 <a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf">LeNet5</a>。当时，LeNet 架构主要用于字符识别任务，比如读取邮政编码、数字等等。</p><p>接下来，我们将会了解 LeNet 架构是如何学会识别图像的。近年来有许多在 LeNet 上面改进的新架构被提出来，但它们都使用了 LeNet 中的主要概念，如果你对 LeNet 有一个清晰的认识，就相对比较容易理解。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5azN1dHJjbmozMGtzMDR5ZGhoLmpwZw?x-oss-process=image/format,png" alt="图 3"></p><p>上图中的卷积神经网络和原始的 LeNet 的结构比较相似，可以把输入的图像分为四类：狗、猫、船或者鸟（原始的 LeNet 主要用于字符识别任务）。正如上图说示，当输入为一张船的图片时，网络可以正确的从四个类别中把最高的概率分配给船（0.94）。在输出层所有概率的和应该为一（本文稍后会解释）。</p><p>There are four main operations in the ConvNet shown in Figure 3 above: 在上图中的 ConvNet 有四个主要操作：</p><ol><li>卷积</li><li>非线性处理（ReLU）</li><li>池化或者亚采样</li><li>分类（全连接层）</li></ol><p>这些操作对于各个卷积神经网络来说都是基本组件，因此理解它们的工作原理有助于充分了解卷积神经网络。下面我们将会尝试理解各步操作背后的原理。</p><h3 id="图像是像素值的矩阵">图像是像素值的矩阵</h3><p>本质上来说，每张图像都可以表示为像素值的矩阵：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzY3MTExZjZhbHkxZmh5aHpnaHVucmcyMDVjMDVjZGcwLmdpZg" alt="图4"></p><p><a href="https://en.wikipedia.org/wiki/Channel_(digital_image)">通道</a> 常用于表示图像的某种组成。一个标准数字相机拍摄的图像会有三通道 - 红、绿和蓝；你可以把它们看作是互相堆叠在一起的二维矩阵（每一个通道代表一个颜色），每个通道的像素值在 0 到 255 的范围内。</p><p><a href="https://en.wikipedia.org/wiki/Grayscale">灰度</a>图像，仅仅只有一个通道。在本篇文章中，我们仅考虑灰度图像，这样我们就只有一个二维的矩阵来表示图像。矩阵中各个像素的值在 0 到 255 的范围内——零表示黑色，255 表示白色。</p><h3 id="卷积">卷积</h3><p>卷积神经网络的名字就来自于其中的<a href="https://en.wikipedia.org/wiki/Convolution">卷积操作</a>。卷积的主要目的是为了从输入图像中提取特征。卷积可以通过从输入的一小块数据中学到图像的特征，并可以保留像素间的空间关系。我们在这里并不会详细讲解卷积的数学细节，但我们会试着理解卷积是如何处理图像的。</p><p>As we discussed above, every image can be considered as a matrix of pixel values. Consider a 5 x 5 image whose pixel values are only 0 and 1 (note that for a grayscale image, pixel values range from 0 to 255, the green matrix below is a special case where pixel values are only 0 and 1): 正如我们上面所说，每张图像都可以看作是像素值的矩阵。考虑一下一个 5 x 5 的图像，它的像素值仅为 0 或者 1（注意对于灰度图像而言，像素值的范围是 0 到 255，下面像素值为 0 和 1 的绿色矩阵仅为特例）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4Mi5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a2Q1YXo4amozMDNqMDM3bXgxLmpwZw?x-oss-process=image/format,png" alt="图 5"></p><p>同时，考虑下另一个 3 x 3 的矩阵，如下所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4Mi5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a2R4YWxpdGozMDIyMDFydDhqLmpwZw?x-oss-process=image/format,png" alt="图 6"></p><p>接下来，5 x 5 的图像和 3 x 3 的矩阵的卷积可以按下图所示的动画一样计算：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzY3MTExZjZhbHkxZmh5a2VzNXNmZmcyMDdnMDVnZGdmLmdpZg" alt="图 7"></p><p>现在停下来好好理解下上面的计算是怎么完成的。我们用橙色的矩阵在原始图像（绿色）上滑动，每次滑动一个像素（也叫做“步长”），在每个位置上，我们计算对应元素的乘积（两个矩阵间），并把乘积的和作为最后的结果，得到输出矩阵（粉色）中的每一个元素的值。注意，3 x 3 的矩阵每次步长中仅可以“看到”输入图像的一部分。</p><p>在 CNN 的术语中，3x3 的矩阵叫做“滤波器（filter）”或者“核（kernel）”或者“特征检测器（feature detector）”，通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。记住滤波器在原始输入图像上的作用是特征检测器。</p><p>从上面图中的动画可以看出，对于同样的输入图像，不同值的滤波器将会生成不同的特征图。比如，对于下面这张输入图像：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5aHRmd3Z2M2ozMDNxMDNvM3l4LmpwZw?x-oss-process=image/format,png" alt="xiaolu"></p><p>In the table below, we can see the effects of convolution of the above image with different filters. As shown, we can perform operations such as Edge Detection, Sharpen and Blur just by changing the numeric values of our filter matrix before the convolution operation <a href="https://en.wikipedia.org/wiki/Channel_(digital_image)">8</a> – this means that different filters can detect different features from an image, for example edges, curves etc. More such examples are available in Section 8.2.4 here.</p><p>在下表中，我们可以看到不同滤波器对上图卷积的效果。正如表中所示，通过在卷积操作前修改滤波矩阵的数值，我们可以进行诸如边缘检测、锐化和模糊等操作 —— 这表明不同的滤波器可以从图中检测到不同的特征，比如边缘、曲线等。在<a href="https://docs.gimp.org/en/plug-in-convmatrix.html">这里的 8.2.4 部分</a>中可以看到更多的例子。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4My5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a2Z6eDZ3a2ozMGlhMHUyZ3RjLmpwZw?x-oss-process=image/format,png" alt="卷积"></p><p>另一个理解卷积操作的好方法是看下面这张图的动画：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzY3MTExZjZhbHkxZmh5a2ltdHB2OGcyMGRjMDdrN3dtLmdpZg" alt="卷积"></p><p>滤波器（红色框）在输入图像滑过（卷积操作），生成一个特征图。另一个滤波器（绿色框）在同一张图像上卷积可以得到一个不同的特征图。注意卷积操作可以从原图上获取局部依赖信息。同时注意这两个不同的滤波器是如何从同一张图像上生成不同的特征图。记住上面的图像和两个滤波器仅仅是我们上面讨论的数值矩阵。</p><p>在实践中，CNN 会在训练过程中学习到这些滤波器的值（尽管我们依然需要在训练前指定诸如滤波器的个数、滤波器的大小、网络架构等参数）。我们使用的滤波器越多，提取到的图像特征就越多，网络所能在未知图像上识别的模式也就越好。</p><p>特征图的大小（卷积特征）由下面三个参数控制，我们需要在卷积前确定它们：</p><ul><li>深度（Depth）：深度对应的是卷积操作所需的滤波器个数。在下图的网络中，我们使用三个不同的滤波器对原始图像进行卷积操作，这样就可以生成三个不同的特征图。你可以把这三个特征图看作是堆叠的 2d 矩阵，那么，特征图的“深度”就是三。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5aWExMGxzeGozMG1hMGI2bXptLmpwZw?x-oss-process=image/format,png" alt="深度"></p><ul><li>步长（Stride）：步长是我们在输入矩阵上滑动滤波矩阵的像素数。当步长为 1 时，我们每次移动滤波器一个像素的位置。当步长为 2 时，我们每次移动滤波器会跳过 2 个像素。步长越大，将会得到更小的特征图。</li><li>零填充（Zero-padding）：有时，在输入矩阵的边缘使用零值进行填充，这样我们就可以对输入图像矩阵的边缘进行滤波。零填充的一大好处是可以让我们控制特征图的大小。使用零填充的也叫做泛卷积，不适用零填充的叫做严格卷积。这个概念在下面的参考文献 14 中介绍的非常详细。</li></ul><h3 id="非线性简介（ReLU）">非线性简介（ReLU）</h3><p>An additional operation called ReLU has been used after every Convolution operation in Figure 3 above. ReLU stands for Rectified Linear Unit and is a non-linear operation. Its output is given by:</p><p>在上面图中，在每次的卷积操作后都使用了一个叫做 ReLU 的操作。ReLU 表示修正线性单元（Rectified Linear Unit），是一个非线性操作。它的输入如下所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5aWQ5bG9pcGozMHRyMDljM3pqLmpwZw?x-oss-process=image/format,png" alt="ReLU"></p><p>ReLU 是一个元素级别的操作（应用到各个像素），并将特征图中的所有小于 0 的像素值设置为零。ReLU 的目的是在 ConvNet 中引入非线性，因为在大部分的我们希望 ConvNet 学习的实际数据是非线性的（卷积是一个线性操作——元素级别的矩阵相乘和相加，所以我们需要通过使用非线性函数 ReLU 来引入非线性。</p><p>ReLU 操作可以从下面的图中理解。它展示的 ReLU 操作是应用到上面图 6 得到的特征图之一。这里的输出特征图也可以看作是“修正”过的特征图。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a2t5czd4ZmozMTVrMGZrdGVwLmpwZw?x-oss-process=image/format,png" alt="ReLU"></p><p>其他非线性函数，比如 tanh 或者 sigmoid 也可以用来替代 ReLU，但 ReLU 在大部分情况下表现是更好的。</p><h3 id="池化操作">池化操作</h3><p>空间池化（Spatial Pooling）（也叫做亚采用或者下采样）降低了各个特征图的维度，但可以保持大部分重要的信息。空间池化有下面几种方式：最大化、平均化、加和等等。</p><p>对于最大池化（Max Pooling），我们定义一个空间邻域（比如，2x2 的窗口），并从窗口内的修正特征图中取出最大的元素。除了取最大元素，我们也可以取平均（Average Pooling）或者对窗口内的元素求和。在实际中，最大池化被证明效果更好一些。</p><p>下面的图展示了使用 2x2 窗口在修正特征图（在卷积 + ReLU 操作后得到）使用最大池化的例子。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4Mi5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5aWM1Z29uY2ozMHJnMG5lNDM2LmpwZw?x-oss-process=image/format,png" alt="ReLU"></p><p>我们以 2 个元素（也叫做“步长”）滑动我们 2x2 的窗口，并在每个区域内取最大值。如上图所示，这样操作可以降低我们特征图的维度。</p><p>在下图展示的网络中，池化操作是分开应用到各个特征图的（注意，因为这样的操作，我们可以从三个输入图中得到三个输出图）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a2xzcTNmcGozMG1hMGM3Z28wLmpwZw?x-oss-process=image/format,png" alt="网络"></p><p>下图展示了在图 9 中我们在 ReLU 操作后得到的修正特征图的池化操作的效果。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a21rMWVoYWozMHoyMGV5d2h0LmpwZw?x-oss-process=image/format,png" alt="池化"></p><p>池化函数可以逐渐降低输入表示的空间尺度。特别地，池化：</p><ul><li>使输入表示（特征维度）变得更小，并且网络中的参数和计算的数量更加可控的减小，因此，可以控制过拟合</li><li>使网络对于输入图像中更小的变化、冗余和变换变得不变性（输入的微小冗余将不会改变池化的输出——因为我们在局部邻域中使用了最大化/平均值的操作。</li><li>帮助我们获取图像最大程度上的尺度不变性（准确的词是“不变性”）。它非常的强大，因为我们可以检测图像中的物体，无论它们位置在哪里（参考 <a href="https://tvax4.sinaimg.cn/mw690/0065SY2ely1fhyia10lsxj30ma0b6mzm.jpg">18</a> 和 <a href="https://tvax4.sinaimg.cn/mw690/0065SY2ely1fhyid9loipj30tr09c3zj.jpg">19</a> 获取详细信息）。</li></ul><h3 id="目前为止的故事">目前为止的故事</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a25oZWN3Z2ozMTVrMDl2NzhzLmpwZw?x-oss-process=image/format,png" alt="网络"></p><p>到目前为止我们了解了卷积、ReLU 和池化是如何操作的。理解这些层是构建任意 CNN 的基础是很重要的。正如上图所示，我们有两组卷积、ReLU &amp; 池化层 —— 第二组卷积层使用六个滤波器对第一组的池化层的输出继续卷积，得到一共六个特征图。接下来对所有六个特征图应用 ReLU。接着我们对六个修正特征图分别进行最大池化操作。</p><p>这些层一起就可以从图像中提取有用的特征，并在网络中引入非线性，减少特征维度，同时保持这些特征具有某种程度上的尺度变化不变性。</p><p>第二组池化层的输出作为全连接层的输入，我们会在下一部分介绍全连接层。</p><h3 id="全连接层">全连接层</h3><p>全连接层是传统的多层感知器，在输出层使用的是 softmax 激活函数（也可以使用其他像 SVM 的分类器，但在本文中只使用 softmax）。“全连接（Fully Connected）”这个词表明前面层的所有神经元都与下一层的所有神经元连接。如果你对多层感知器不熟悉的话，我推荐你阅读<a href="https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/">这篇文章</a>。</p><p>卷积和池化层的输出表示了输入图像的高级特征。全连接层的目的是为了使用这些特征把输入图像基于训练数据集进行分类。比如，在下面图中我们进行的图像分类有四个可能的输出结果（注意下图并没有显示全连接层的节点连接）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a29qM2Z2cWozMHF3MDhmZGkyLmpwZw?x-oss-process=image/format,png" alt="全连接"></p><p>除了分类，添加一个全连接层也（一般）是学习这些特征的非线性组合的简单方法。从卷积和池化层得到的大多数特征可能对分类任务有效，但这些特征的组合可能会更好。</p><p>从全连接层得到的输出概率和为 1。这个可以在输出层使用 softmax 作为激活函数进行保证。softmax 函数输入一个任意大于 0 值的矢量，并把它们转换为零一之间的数值矢量，其和为一。</p><h3 id="把它们组合起来——使用反向传播进行训练">把它们组合起来——使用反向传播进行训练</h3><p>正如上面讨论的，卷积 + 池化层的作用是从输入图像中提取特征，而全连接层的作用是分类器。</p><p>注意在下面的图中，因为输入的图像是船，对于船这一类的目标概率是 1，而其他三类的目标概率是 0，即</p><ul><li>输入图像 = 船</li><li>目标矢量 = [0, 0, 1, 0]</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4My5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a3BlMG41b2ozMTVrMGVtbjF5LmpwZw?x-oss-process=image/format,png" alt="网络"></p><p>完整的卷积网络的训练过程可以总结如下：</p><ul><li>第一步：我们初始化所有的滤波器，使用随机值设置参数/权重</li><li>第二步：网络接收一张训练图像作为输入，通过前向传播过程（卷积、ReLU 和池化操作，以及全连接层的前向传播），找到各个类的输出概率<ul><li>我们假设船这张图像的输出概率是 [0.2, 0.4, 0.1, 0.3]</li><li>因为对于第一张训练样本的权重是随机分配的，输出的概率也是随机的</li></ul></li><li>第三步：在输出层计算总误差（计算 4 类的和）<ul><li>Total Error = ∑  ½ (target probability – output probability) ²</li></ul></li><li>第四步：使用反向传播算法，根据网络的权重计算误差的梯度，并使用梯度下降算法更新所有滤波器的值/权重以及参数的值，使输出误差最小化<ul><li>权重的更新与它们对总误差的占比有关</li><li>当同样的图像再次作为输入，这时的输出概率可能会是 [0.1, 0.1, 0.7, 0.1]，这就与目标矢量 [0, 0, 1, 0] 更接近了</li><li>这表明网络已经通过调节权重/滤波器，可以正确对这张特定图像的分类，这样输出的误差就减小了</li><li>像滤波器数量、滤波器大小、网络结构等这样的参数，在第一步前都是固定的，在训练过程中保持不变——仅仅是滤波器矩阵的值和连接权重在更新</li></ul></li><li>第五步：对训练数据中所有的图像重复步骤 1 ~ 4</li></ul><p>上面的这些步骤可以__训练__ ConvNet —— 这本质上意味着对于训练数据集中的图像，ConvNet 在更新了所有权重和参数后，已经优化为可以对这些图像进行正确分类。</p><p>当一张新的（未见过的）图像作为 ConvNet 的输入，网络将会再次进行前向传播过程，并输出各个类别的概率（对于新的图像，输出概率是使用已经在前面训练样本上优化分类的参数进行计算的）。如果我们的训练数据集非常的大，网络将会（有希望）对新的图像有很好的泛化，并把它们分到正确的类别中去。</p><p><strong>注 1</strong>: 上面的步骤已经简化，也避免了数学详情，只为提供训练过程的直观内容。可以参考文献 <a href="https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/">4</a> 和 <a href="https://tvax2.sinaimg.cn/mw690/0065SY2ely1fhykdxalitj302201rt8j.jpg">12</a> 了解数学公式和完整过程。</p><p><strong>注 2</strong>:在上面的例子中我们使用了两组卷积和池化层。然而请记住，这些操作可以在一个 ConvNet 中重复多次。实际上，现在有些表现最好的 ConvNet 拥有多达十几层的卷积和池化层！同时，每次卷积层后面不一定要有池化层。如下图所示，我们可以在池化操作前连续使用多个卷积 + ReLU 操作。还有，请注意 ConvNet 的各层在下图中是如何可视化的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4My5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a3FiNzQzMWozMHhvMGdjNDlpLmpwZw?x-oss-process=image/format,png" alt="car"></p><h3 id="卷积神经网络的可视化">卷积神经网络的可视化</h3><p>一般而言，越多的卷积步骤，网络可以学到的识别特征就越复杂。比如，ConvNet 的图像分类可能在第一层从原始像素中检测出边缘，然后在第二层使用边缘检测简单的形状，接着使用这些形状检测更高级的特征，比如更高层的人脸。下面的图中展示了这些内容——我们使用<a href="https://web.eecs.umich.edu/~honglak/icml09-ConvolutionalDeepBeliefNetworks.pdf">卷积深度置信网络</a>学习到的特征，这张图仅仅是用来证明上面的内容（这仅仅是一个例子：真正的卷积滤波器可能会检测到对我们毫无意义的物体）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4My5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5aWU3OGhsbmozMGRnMGU2MHZzLmpwZw?x-oss-process=image/format,png" alt="demo"></p><p>Adam Harley 创建了一个卷积神经网络的可视化结果，使用的是 MNIST 手写数字的训练集<a href="https://tvax4.sinaimg.cn/mw690/67111f6aly1fhykes5sffg207g05gdgf.gif">13</a>。我强烈建议使用它来理解 CNN 的工作原理。</p><p>我们可以在下图中看到网络是如何识别输入 “8” 的。注意下图中的可视化并没有单独展示 ReLU 操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a3JvaGlhamozMTVrMG5qNGM5LmpwZw?x-oss-process=image/format,png" alt="Conv_all"></p><p>输入图像包含 1024 个像素（32 x 32 大小），第一个卷积层（卷积层 1）由六个独特的 5x5 （步长为 1）的滤波器组成。如图可见，使用六个不同的滤波器得到一个深度为六的特征图。</p><p>卷积层 1 后面是池化层 1，在卷积层 1 得到的六个特征图上分别进行 2x2 的最大池化（步长为 2）的操作。你可以在池化层上把鼠标移动到任意的像素上，观察在前面卷积层（如上图所示）得到的 4x4 的小格。你会发现 4x4 小格中的最大值（最亮）的像素将会进入到池化层。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4MS5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a3Nob29vYmozMTVrMDl5bjVtLmpwZw?x-oss-process=image/format,png" alt="pooling"></p><p>池化层 1 后面的是十六个 5x5 （步长为 1）的卷积滤波器，进行卷积操作。后面就是池化层 2，进行 2x2 的最大池化（步长为 2）的操作。这两层的概念和前面描述的一样。</p><p>接下来我们就到了三个全连接层。它们是：</p><ul><li>第一个全连接层有 120 个神经元</li><li>第二层全连接层有 100 个神经元</li><li>第三个全连接层有 10 个神经元，对应 10 个数字——也就做输出层</li></ul><p>注意在下图中，输出层中的 10 个节点的各个都与第二个全连接层的所有 100 个节点相连（因此叫做全连接）。</p><p>同时，注意在输出层那个唯一的亮的节点是如何对应于数字 “8” 的——这表明网络把我们的手写数字正确分类（越亮的节点表明从它得到的输出值越高，即，8 是所有数字中概率最高的）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4Mi5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5a3Q2Z3J4ZmozMTVrMDhtdGN2LmpwZw?x-oss-process=image/format,png" alt="final"></p><p>同样的 3D 可视化可以在<a href="http://scs.ryerson.ca/~aharley/vis/conv/">这里</a>看到。</p><h3 id="其他的-ConvNet-架构">其他的 ConvNet 架构</h3><p>卷积神经网络从上世纪 90 年代初期开始出现。我们上面提到的 LeNet 是早期卷积神经网络之一。其他有一定影响力的架构如下所示<a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf">3</a>：</p><ul><li>LeNet (1990s)： 本文已介绍。</li><li>1990s to 2012：在上世纪 90 年代后期至 2010 年初期，卷积神经网络进入孵化期。随着数据量和计算能力的逐渐发展，卷积神经网络可以处理的问题变得越来越有趣。</li><li>AlexNet (2012) – 在 2012，Alex Krizhevsky （与其他人）发布了 <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">AlexNet</a>，它是比 LeNet 更深更宽的版本，并在 2012 年的 ImageNet 大规模视觉识别大赛（ImageNet Large Scale Visual Recognition Challenge，ILSVRC）中以巨大优势获胜。这对于以前的方法具有巨大的突破，当前 CNN 大范围的应用也是基于这个工作。</li><li>ZF Net (2013) – ILSVRC 2013 的获胜者是来自 Matthew Zeiler 和 Rob Fergus 的卷积神经网络。它以 <a href="https://arxiv.org/abs/1311.2901">ZFNet</a> （Zeiler &amp; Fergus Net 的缩写）出名。它是在 AlexNet 架构超参数上进行调整得到的效果提升。</li><li>GoogLeNet (2014) – ILSVRC 2014 的获胜者是来自于 Google 的 <a href="https://arxiv.org/abs/1409.4842">Szegedy</a>等人的卷积神经网络。它的主要贡献在于使用了一个 Inception 模块，可以大量减少网络的参数个数（4M，AlexNet 有 60M 的参数）。</li><li>VGGNet (2014) – 在 ILSVRC 2014 的领先者中有一个 <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">VGGNet</a> 的网络。它的主要贡献是展示了网络的深度（层数）对于性能具有很大的影响。</li><li>ResNets (2015) – <a href="https://arxiv.org/abs/1512.03385">残差网络</a>是何凯明（和其他人）开发的，并赢得 ILSVRC 2015 的冠军。ResNets 是当前卷积神经网络中最好的模型，也是实践中使用 ConvNet 的默认选择（截至到 2016 年五月）。</li><li>DenseNet (2016 八月) – 近来由 Gao Huang （和其他人）发表的，<a href="https://arxiv.org/abs/1608.06993">the Densely Connected Convolutional Network</a> 的各层都直接于其他层以前向的方式连接。DenseNet 在五种竞争积累的目标识别基准任务中，比以前最好的架构有显著的提升。可以在<a href="https://github.com/liuzhuang13/DenseNet">这里</a>看 Torch 实现。</li></ul><h3 id="总结">总结</h3><p>在本篇文章中，我尝试使用简单的方式来解释卷积神经网络背后的主要概念。我简化/跳过了一些细节，但希望本篇文章可以让你对它们有一定的了解。</p><p>本文最开始是受 Denny Britz 的<a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/">理解用于自然语言处理的卷积神经网络</a>（我强烈建议阅读）启发，大量的解释也是基于那篇文章。如果你想要对这些概念有更深的理解，我建议你浏览一下 <a href="http://cs231n.stanford.edu/">Stanford 的 ConvNet 课程</a>中的<a href="https://cs231n.github.io/">笔记</a>，以及下面所列的参考文献。如果你对上面的概念有什么疑问，或者有问题和建议，欢迎在下面留言。</p><p>本文中使用的所有图像和动画的版权都归下面参考文献中对应作者所有。</p><h3 id="参考文献">参考文献</h3><ol><li><a href="https://www.clarifai.com/">Clarifai Home Page</a></li><li>Shaoqing Ren, et al, “Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks”, 2015, <a href="https://arxiv.org/pdf/1506.01497v3.pdf">arXiv:1506.01497</a></li><li><a href="https://culurciello.github.io/tech/2016/06/04/nets.html">Neural Network Architectures</a>, Eugenio Culurciello’s blog</li><li><a href="https://cs231n.github.io/convolutional-networks/">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a></li><li><a href="https://www.clarifai.com/technology">Clarifai / Technology</a></li><li><a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721#.2gfx5zcw3">Machine Learning is Fun! Part 3: Deep Learning and Convolutional Neural Networks</a></li><li><a href="http://deeplearning.stanford.edu/wiki/index.php/Feature_extraction_using_convolution">Feature extraction using convolution, Stanford</a></li><li><a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)">Wikipedia article on Kernel (image processing)</a></li><li><a href="http://cs.nyu.edu/~fergus/tutorials/deep_learning_cvpr12">Deep Learning Methods for Vision, CVPR 2012 Tutorial</a></li><li><a href="http://mlss.tuebingen.mpg.de/2015/slides/fergus/Fergus_1.pdf">Neural Networks by Rob Fergus, Machine Learning Summer School 2015</a></li><li><a href="https://stats.stackexchange.com/a/182122/53914">What do the fully connected layers do in CNNs?</a></li><li><a href="http://andrew.gibiansky.com/blog/machine-learning/convolutional-neural-networks/">Convolutional Neural Networks, Andrew Gibiansky</a></li><li>A. W. Harley, “An Interactive Node-Link Visualization of Convolutional Neural Networks,” in ISVC, pages 867-877, 2015 (<a href="http://scs.ryerson.ca/~aharley/vis/harley_vis_isvc15.pdf">link</a>)</li><li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/">Understanding Convolutional Neural Networks for NLP</a></li><li><a href="http://andrew.gibiansky.com/blog/machine-learning/convolutional-neural-networks/">Backpropagation in Convolutional Neural Networks</a></li><li><a href="https://adeshpande3.github.io/adeshpande3.github.io/A-Beginner's-Guide-To-Understanding-Convolutional-Neural-Networks-Part-2/">A Beginner’s Guide To Understanding Convolutional Neural Networks</a> Vincent Dumoulin, et al, “A guide to convolution arithmetic for deep learning”, 2015, <a href="https://arxiv.org/pdf/1603.07285v1.pdf">arXiv:1603.07285</a></li><li><a href="https://github.com/rasbt/python-machine-learning-book/blob/master/faq/difference-deep-and-normal-learning.md">What is the difference between deep learning and usual machine learning?</a></li><li><a href="https://github.com/rasbt/python-machine-learning-book/blob/master/faq/difference-deep-and-normal-learning.md">How is a convolutional neural network able to learn invariant features?</a></li><li>[A Taxonomy of Deep Convolutional Neural Nets for Computer Vision](</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://hackcv.com/2016/10/%E7%BF%BB%E8%AF%91-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%B4%E8%A7%82%E8%A7%A3%E9%87%8A/&quot;&gt;原文地址&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;什么是卷积神经网络？为什么它们很重要？&quot;&gt;什么是卷积神经网络？为什么它们很重要？&lt;/h2&gt;
&lt;p&gt;卷积神经网络（ConvNets 或者 CNNs）属于神经网络的范畴，已经在诸如图像识别和分类的领域证明了其高效的能力。卷积神经网络可以成功识别人脸、物体和交通信号，从而为机器人和自动驾驶汽车提供视力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmF4NC5zaW5haW1nLmNuL213NjkwLzAwNjVTWTJlbHkxZmh5azE3Y3JwNGozMTVxMGZ0dHpyLmpwZw?x-oss-process=image/format,png&quot; alt=&quot;图 1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="翻译" scheme="http://example.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/10/13/hello-world/"/>
    <id>http://example.com/2020/10/13/hello-world/</id>
    <published>2020-10-13T03:02:04.360Z</published>
    <updated>2020-10-13T07:21:59.088Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
